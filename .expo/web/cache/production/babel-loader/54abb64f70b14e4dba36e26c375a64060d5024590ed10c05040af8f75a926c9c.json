{"ast":null,"code":"import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";import NativeReanimatedModule from\"./NativeReanimated\";import{shouldBeUseWeb}from\"./PlatformChecker\";import{registerWorkletStackDetails}from\"./errors\";import{jsVersion}from\"./platform-specific/jsVersion\";var USE_STUB_IMPLEMENTATION=shouldBeUseWeb();var _shareableCache=new WeakMap();var _shareableFlag=Symbol('shareable flag');var MAGIC_KEY='REANIMATED_MAGIC_KEY';function isHostObject(value){return MAGIC_KEY in value;}export function registerShareableMapping(shareable,shareableRef){if(USE_STUB_IMPLEMENTATION){return;}_shareableCache.set(shareable,shareableRef||_shareableFlag);}function isPlainJSObject(object){return Object.getPrototypeOf(object)===Object.prototype;}var _worklet_8747950959025_init_data={code:\"function anonymous(){return new Proxy({},{get:function(_,prop){if(prop==='_isReanimatedSharedValue'){return false;}throw new Error(\\\"Trying to access property `\\\"+prop+\\\"` of an object which cannot be sent to the UI runtime.\\\");},set:function(){throw new Error('Trying to write to an object which cannot be sent to the UI runtime.');}});}\",location:\"/Users/peterputros/Desktop/PosMate/node_modules/react-native-reanimated/lib/module/reanimated2/shareables.js\"};var INACCESSIBLE_OBJECT={__init:function(){var _f=function _f(){return new Proxy({},{get:function get(_,prop){if(prop==='_isReanimatedSharedValue'){return false;}throw new Error(`Trying to access property \\`${prop}\\` of an object which cannot be sent to the UI runtime.`);},set:function set(){throw new Error('Trying to write to an object which cannot be sent to the UI runtime.');}});};_f._closure={};_f.__initData=_worklet_8747950959025_init_data;_f.__workletHash=8747950959025;return _f;}()};var DETECT_CYCLIC_OBJECT_DEPTH_THRESHOLD=30;var processedObjectAtThresholdDepth;export function makeShareableCloneRecursive(value){var shouldPersistRemote=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var depth=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;if(USE_STUB_IMPLEMENTATION){return value;}if(depth>=DETECT_CYCLIC_OBJECT_DEPTH_THRESHOLD){if(depth===DETECT_CYCLIC_OBJECT_DEPTH_THRESHOLD){processedObjectAtThresholdDepth=value;}else if(value===processedObjectAtThresholdDepth){throw new Error('Trying to convert a cyclic object to a shareable. This is not supported.');}}else{processedObjectAtThresholdDepth=undefined;}var type=typeof value;var isTypeObject=type==='object';var isTypeFunction=type==='function';if((isTypeObject||isTypeFunction)&&value!==null){var cached=_shareableCache.get(value);if(cached===_shareableFlag){return value;}else if(cached!==undefined){return cached;}else{var toAdapt;if(Array.isArray(value)){toAdapt=value.map(function(element){return makeShareableCloneRecursive(element,shouldPersistRemote,depth+1);});}else if(isTypeFunction&&value.__workletHash===undefined){toAdapt=value;}else if(isHostObject(value)){toAdapt=value;}else if(isPlainJSObject(value)||isTypeFunction){toAdapt={};if(value.__workletHash!==undefined){if(__DEV__){if(value.__version!==jsVersion){throw new Error(`[Reanimated] Mismatch between JavaScript code version and Reanimated Babel plugin version (${jsVersion} vs. ${value.__version}). Please clear your Metro bundler cache with \\`yarn start --reset-cache\\`,\n              \\`npm start -- --reset-cache\\` or \\`expo start -c\\` and run the app again.`);}registerWorkletStackDetails(value.__workletHash,value.__stackDetails);delete value.__stackDetails;}toAdapt.__initData=makeShareableCloneRecursive(value.__initData,true,depth+1);delete value.__initData;}for(var _ref of Object.entries(value)){var _ref2=_slicedToArray(_ref,2);var key=_ref2[0];var element=_ref2[1];toAdapt[key]=makeShareableCloneRecursive(element,shouldPersistRemote,depth+1);}}else{var inaccessibleObject=makeShareableCloneRecursive(INACCESSIBLE_OBJECT);_shareableCache.set(value,inaccessibleObject);return inaccessibleObject;}if(__DEV__){Object.freeze(value);}var adopted=NativeReanimatedModule.makeShareableClone(toAdapt,shouldPersistRemote);_shareableCache.set(value,adopted);_shareableCache.set(adopted,_shareableFlag);return adopted;}}return NativeReanimatedModule.makeShareableClone(value,shouldPersistRemote);}var _worklet_15842516739326_init_data={code:\"function makeShareableCloneOnUIRecursive(value){const{USE_STUB_IMPLEMENTATION}=this._closure;if(USE_STUB_IMPLEMENTATION){return value;}function cloneRecursive(value){const type=typeof value;if((type==='object'||type==='function')&&value!==null){let toAdapt;if(Array.isArray(value)){toAdapt=value.map(function(element){return cloneRecursive(element);});}else if(value!==undefined){toAdapt={};for(const[key,element]of Object.entries(value)){toAdapt[key]=cloneRecursive(element);}}return _makeShareableClone(toAdapt);}return _makeShareableClone(value);}return cloneRecursive(value);}\",location:\"/Users/peterputros/Desktop/PosMate/node_modules/react-native-reanimated/lib/module/reanimated2/shareables.js\"};export var makeShareableCloneOnUIRecursive=function(){var _f=function _f(value){if(USE_STUB_IMPLEMENTATION){return value;}function cloneRecursive(value){var type=typeof value;if((type==='object'||type==='function')&&value!==null){var toAdapt;if(Array.isArray(value)){toAdapt=value.map(function(element){return cloneRecursive(element);});}else if(value!==undefined){toAdapt={};for(var _ref3 of Object.entries(value)){var _ref4=_slicedToArray(_ref3,2);var key=_ref4[0];var element=_ref4[1];toAdapt[key]=cloneRecursive(element);}}return _makeShareableClone(toAdapt);}return _makeShareableClone(value);}return cloneRecursive(value);};_f._closure={USE_STUB_IMPLEMENTATION:USE_STUB_IMPLEMENTATION};_f.__initData=_worklet_15842516739326_init_data;_f.__workletHash=15842516739326;return _f;}();var _worklet_10632798355907_init_data={code:\"function anonymous(){const{value}=this._closure;return value;}\",location:\"/Users/peterputros/Desktop/PosMate/node_modules/react-native-reanimated/lib/module/reanimated2/shareables.js\"};export function makeShareable(value){if(USE_STUB_IMPLEMENTATION){return value;}var handle=makeShareableCloneRecursive({__init:function(){var _f=function _f(){return value;};_f._closure={value:value};_f.__initData=_worklet_10632798355907_init_data;_f.__workletHash=10632798355907;return _f;}()});registerShareableMapping(value,handle);return value;}","map":{"version":3,"mappings":"iEAAA,MAAOA,uBAAsB,0BAE7B,OAASC,cAAc,yBACvB,OAASC,2BAA2B,gBACpC,OAASC,SAAS,qCAMlB,GAAMC,wBAAuB,CAAGH,cAAc,EAAE,CAEhD,GAAMI,gBAAe,CAAG,GAAIC,QAAO,EAGhC,CAGH,GAAMC,eAAc,CAAGC,MAAM,CAAC,gBAAgB,CAAC,CAE/C,GAAMC,UAAS,CAAG,sBAAsB,CAExC,QAASC,aAAYA,CAACC,KAAU,CAAW,CAKzC,MAAOF,UAAS,GAAIE,MAAK,CAC3B,CAEA,MAAO,SAASC,yBAAwBA,CACtCC,SAAc,CACdC,YAAgC,CAC1B,CACN,GAAIV,uBAAuB,CAAE,CAC3B,OACF,CACAC,eAAe,CAACU,GAAG,CAACF,SAAS,CAAEC,YAAY,EAAIP,cAAc,CAAC,CAChE,CAEA,QAASS,gBAAeA,CAACC,MAAc,CAAE,CACvC,MAAOC,OAAM,CAACC,cAAc,CAACF,MAAM,CAAC,GAAKC,MAAM,CAACE,SAAS,CAC3D,0fASA,GAAMC,oBAAmB,CAAG,CAC1BC,MAAM,gCAAQ,CAEZ,MAAO,IAAIC,MAAK,CACd,CAAC,CAAC,CACF,CACEC,GAAG,CAAEA,aAACC,CAAM,CAAEC,IAAY,CAAK,CAC7B,GAAIA,IAAI,GAAK,0BAA0B,CAAE,CAQvC,MAAO,MAAK,CACd,CACA,KAAM,IAAIC,MAAK,CACZ,+BAA8BD,IAAK,yDAAwD,CAC7F,CACH,CAAC,CACDX,GAAG,CAAEA,cAAM,CACT,KAAM,IAAIY,MAAK,CACb,sEAAsE,CACvE,CACH,CACF,CAAC,CACF,CACH,4GACF,CAAC,CAED,GAAMC,qCAAoC,CAAG,EAAE,CAG/C,GAAIC,gCAAoC,CAExC,MAAO,SAASC,4BAA2BA,CACzCnB,KAAU,CAGO,IAFjBoB,oBAAmB,2DAAG,KAAK,IAC3BC,MAAK,2DAAG,CAAC,CAET,GAAI5B,uBAAuB,CAAE,CAC3B,MAAOO,MAAK,CACd,CACA,GAAIqB,KAAK,EAAIJ,oCAAoC,CAAE,CAMjD,GAAII,KAAK,GAAKJ,oCAAoC,CAAE,CAClDC,+BAA+B,CAAGlB,KAAK,CACzC,CAAC,IAAM,IAAIA,KAAK,GAAKkB,+BAA+B,CAAE,CACpD,KAAM,IAAIF,MAAK,CACb,0EAA0E,CAC3E,CACH,CACF,CAAC,IAAM,CACLE,+BAA+B,CAAGI,SAAS,CAC7C,CAEA,GAAMC,KAAI,CAAG,MAAOvB,MAAK,CACzB,GAAMwB,aAAY,CAAGD,IAAI,GAAK,QAAQ,CACtC,GAAME,eAAc,CAAGF,IAAI,GAAK,UAAU,CAC1C,GAAI,CAACC,YAAY,EAAIC,cAAc,GAAKzB,KAAK,GAAK,IAAI,CAAE,CACtD,GAAM0B,OAAM,CAAGhC,eAAe,CAACmB,GAAG,CAACb,KAAK,CAAC,CACzC,GAAI0B,MAAM,GAAK9B,cAAc,CAAE,CAC7B,MAAOI,MAAK,CACd,CAAC,IAAM,IAAI0B,MAAM,GAAKJ,SAAS,CAAE,CAC/B,MAAOI,OAAM,CACf,CAAC,IAAM,CACL,GAAIC,QAAY,CAChB,GAAIC,KAAK,CAACC,OAAO,CAAC7B,KAAK,CAAC,CAAE,CACxB2B,OAAO,CAAG3B,KAAK,CAAC8B,GAAG,CAAEC,gBAAO,QAC1BZ,4BAA2B,CAACY,OAAO,CAAEX,mBAAmB,CAAEC,KAAK,CAAG,CAAC,CAAC,GACrE,CACH,CAAC,IAAM,IAAII,cAAc,EAAIzB,KAAK,CAACgC,aAAa,GAAKV,SAAS,CAAE,CAE9DK,OAAO,CAAG3B,KAAK,CACjB,CAAC,IAAM,IAAID,YAAY,CAACC,KAAK,CAAC,CAAE,CAI9B2B,OAAO,CAAG3B,KAAK,CACjB,CAAC,IAAM,IAAIK,eAAe,CAACL,KAAK,CAAC,EAAIyB,cAAc,CAAE,CACnDE,OAAO,CAAG,CAAC,CAAC,CACZ,GAAI3B,KAAK,CAACgC,aAAa,GAAKV,SAAS,CAAE,CAErC,GAAIW,OAAO,CAAE,CACX,GAAIjC,KAAK,CAACkC,SAAS,GAAK1C,SAAS,CAAE,CACjC,KAAM,IAAIwB,MAAK,CAAE,8FAA6FxB,SAAU,QAAOQ,KAAK,CAACkC,SAAU;AAC7J,yFAAyF,CAAC,CAC9E,CACA3C,2BAA2B,CACzBS,KAAK,CAACgC,aAAa,CACnBhC,KAAK,CAACmC,cAAc,CACrB,CACD,MAAOnC,MAAK,CAACmC,cAAc,CAC7B,CAMAR,OAAO,CAACS,UAAU,CAAGjB,2BAA2B,CAC9CnB,KAAK,CAACoC,UAAU,CAChB,IAAI,CACJf,KAAK,CAAG,CAAC,CACV,CACD,MAAOrB,MAAK,CAACoC,UAAU,CACzB,CAEA,eAA6B7B,OAAM,CAAC8B,OAAO,CAACrC,KAAK,CAAC,CAAE,qCAAxCsC,IAAG,aAAEP,QAAO,UACtBJ,OAAO,CAACW,GAAG,CAAC,CAAGnB,2BAA2B,CACxCY,OAAO,CACPX,mBAAmB,CACnBC,KAAK,CAAG,CAAC,CACV,CACH,CACF,CAAC,IAAM,CASL,GAAMkB,mBAAkB,CACtBpB,2BAA2B,CAAIT,mBAAmB,CAAC,CACrDhB,eAAe,CAACU,GAAG,CAACJ,KAAK,CAAEuC,kBAAkB,CAAC,CAC9C,MAAOA,mBAAkB,CAC3B,CACA,GAAIN,OAAO,CAAE,CAOX1B,MAAM,CAACiC,MAAM,CAACxC,KAAK,CAAC,CACtB,CACA,GAAMyC,QAAO,CAAGpD,sBAAsB,CAACqD,kBAAkB,CACvDf,OAAO,CACPP,mBAAmB,CACpB,CACD1B,eAAe,CAACU,GAAG,CAACJ,KAAK,CAAEyC,OAAO,CAAC,CACnC/C,eAAe,CAACU,GAAG,CAACqC,OAAO,CAAE7C,cAAc,CAAC,CAC5C,MAAO6C,QAAO,CAChB,CACF,CACA,MAAOpD,uBAAsB,CAACqD,kBAAkB,CAAC1C,KAAK,CAAEoB,mBAAmB,CAAC,CAC9E,6uBAEA,UAAgBuB,gCAA+BA,+BAAI3C,KAAQ,CAAmB,CAE5E,GAAIP,uBAAuB,CAAE,CAG3B,MAAOO,MAAK,CACd,CACA,QAAS4C,eAAcA,CAAI5C,KAAQ,CAAmB,CACpD,GAAMuB,KAAI,CAAG,MAAOvB,MAAK,CACzB,GAAI,CAACuB,IAAI,GAAK,QAAQ,EAAIA,IAAI,GAAK,UAAU,GAAKvB,KAAK,GAAK,IAAI,CAAE,CAChE,GAAI2B,QAAY,CAChB,GAAIC,KAAK,CAACC,OAAO,CAAC7B,KAAK,CAAC,CAAE,CACxB2B,OAAO,CAAG3B,KAAK,CAAC8B,GAAG,CAAEC,gBAAO,QAAKa,eAAc,CAACb,OAAO,CAAC,GAAC,CAC3D,CAAC,IAAM,IAAI/B,KAAK,GAAKsB,SAAS,CAAE,CAC9BK,OAAO,CAAG,CAAC,CAAC,CACZ,gBAA6BpB,OAAM,CAAC8B,OAAO,CAACrC,KAAK,CAAC,CAAE,sCAAxCsC,IAAG,aAAEP,QAAO,UACtBJ,OAAO,CAACW,GAAG,CAAC,CAAGM,cAAc,CAACb,OAAO,CAAC,CACxC,CACF,CACA,MAAOc,oBAAmB,CAAClB,OAAO,CAAC,CACrC,CACA,MAAOkB,oBAAmB,CAAC7C,KAAK,CAAC,CACnC,CACA,MAAO4C,eAAc,CAAC5C,KAAK,CAAC,CAC9B,uCAnOAP,uBAAuB,gGAmOvB,sOAEA,MAAO,SAASqD,cAAaA,CAAI9C,KAAQ,CAAK,CAC5C,GAAIP,uBAAuB,CAAE,CAC3B,MAAOO,MAAK,CACd,CACA,GAAM+C,OAAM,CAAG5B,2BAA2B,CAAC,CACzCR,MAAM,gCAAQ,CAEZ,MAAOX,MAAK,CACd,qBA7OKV,oGA8OP,CAAC,CAAC,CACFW,wBAAwB,CAACD,KAAK,CAAE+C,MAAM,CAAC,CACvC,MAAO/C,MAAK,CACd","names":["NativeReanimatedModule","shouldBeUseWeb","registerWorkletStackDetails","jsVersion","USE_STUB_IMPLEMENTATION","_shareableCache","WeakMap","_shareableFlag","Symbol","MAGIC_KEY","isHostObject","value","registerShareableMapping","shareable","shareableRef","set","isPlainJSObject","object","Object","getPrototypeOf","prototype","INACCESSIBLE_OBJECT","__init","Proxy","get","_","prop","Error","DETECT_CYCLIC_OBJECT_DEPTH_THRESHOLD","processedObjectAtThresholdDepth","makeShareableCloneRecursive","shouldPersistRemote","depth","undefined","type","isTypeObject","isTypeFunction","cached","toAdapt","Array","isArray","map","element","__workletHash","__DEV__","__version","__stackDetails","__initData","entries","key","inaccessibleObject","freeze","adopted","makeShareableClone","makeShareableCloneOnUIRecursive","cloneRecursive","_makeShareableClone","makeShareable","handle"],"sources":["/Users/peterputros/Desktop/PosMate/node_modules/react-native-reanimated/lib/module/reanimated2/shareables.ts"],"sourcesContent":["import NativeReanimatedModule from './NativeReanimated';\nimport { ShareableRef } from './commonTypes';\nimport { shouldBeUseWeb } from './PlatformChecker';\nimport { registerWorkletStackDetails } from './errors';\nimport { jsVersion } from './platform-specific/jsVersion';\n\n// for web/chrome debugger/jest environments this file provides a stub implementation\n// where no shareable references are used. Instead, the objects themselves are used\n// instead of shareable references, because of the fact that we don't have to deal with\n// runnning the code on separate VMs.\nconst USE_STUB_IMPLEMENTATION = shouldBeUseWeb();\n\nconst _shareableCache = new WeakMap<\n  Record<string, unknown>,\n  ShareableRef<any> | symbol\n>();\n// the below symbol is used to represent a mapping from the value to itself\n// this is used to allow for a converted shareable to be passed to makeShareableClone\nconst _shareableFlag = Symbol('shareable flag');\n\nconst MAGIC_KEY = 'REANIMATED_MAGIC_KEY';\n\nfunction isHostObject(value: any): boolean {\n  // We could use JSI to determine whether an object is a host object, however\n  // the below workaround works well and is way faster than an additional JSI call.\n  // We use the fact that host objects have broken implementation of `hasOwnProperty`\n  // and hence return true for all `in` checks regardless of the key we ask for.\n  return MAGIC_KEY in value;\n}\n\nexport function registerShareableMapping(\n  shareable: any,\n  shareableRef?: ShareableRef<any>\n): void {\n  if (USE_STUB_IMPLEMENTATION) {\n    return;\n  }\n  _shareableCache.set(shareable, shareableRef || _shareableFlag);\n}\n\nfunction isPlainJSObject(object: object) {\n  return Object.getPrototypeOf(object) === Object.prototype;\n}\n\n// The below object is used as a replacement for objects that cannot be transferred\n// as shareable values. In makeShareableCloneRecursive we detect if an object is of\n// a plain Object.prototype and only allow such objects to be transferred. This lets\n// us avoid all sorts of react internals from leaking into the UI runtime. To make it\n// possible to catch errors when someone actually tries to access such object on the UI\n// runtime, we use the below Proxy object which is instantiated on the UI runtime and\n// throws whenever someone tries to access its fields.\nconst INACCESSIBLE_OBJECT = {\n  __init: () => {\n    'worklet';\n    return new Proxy(\n      {},\n      {\n        get: (_: any, prop: string) => {\n          if (prop === '_isReanimatedSharedValue') {\n            // not very happy about this check here, but we need to allow for\n            // \"inaccessible\" objects to be tested with isSharedValue check\n            // as it is being used in the mappers when extracing inputs recursively.\n            // Apparently we can't check if a key exists there as HostObjects always\n            // return true for such tests, so the only possibility for us is to\n            // actually access that key and see if it is set to true. We therefore\n            // need to allow for this key to be accessed here.\n            return false;\n          }\n          throw new Error(\n            `Trying to access property \\`${prop}\\` of an object which cannot be sent to the UI runtime.`\n          );\n        },\n        set: () => {\n          throw new Error(\n            'Trying to write to an object which cannot be sent to the UI runtime.'\n          );\n        },\n      }\n    );\n  },\n};\n\nconst DETECT_CYCLIC_OBJECT_DEPTH_THRESHOLD = 30;\n// Below variable stores object that we process in makeShareableCloneRecursive at the specified depth.\n// We use it to check if later on the function reenters with the same object\nlet processedObjectAtThresholdDepth: any;\n\nexport function makeShareableCloneRecursive<T>(\n  value: any,\n  shouldPersistRemote = false,\n  depth = 0\n): ShareableRef<T> {\n  if (USE_STUB_IMPLEMENTATION) {\n    return value;\n  }\n  if (depth >= DETECT_CYCLIC_OBJECT_DEPTH_THRESHOLD) {\n    // if we reach certain recursion depth we suspect that we are dealing with a cyclic object.\n    // this type of objects are not supported and cannot be trasferred as shareable, so we\n    // implement a simple detection mechanism that remembers the value at a given depth and\n    // tests whether we try reenter this method later on with the same value. If that happens\n    // we throw an appropriate error.\n    if (depth === DETECT_CYCLIC_OBJECT_DEPTH_THRESHOLD) {\n      processedObjectAtThresholdDepth = value;\n    } else if (value === processedObjectAtThresholdDepth) {\n      throw new Error(\n        'Trying to convert a cyclic object to a shareable. This is not supported.'\n      );\n    }\n  } else {\n    processedObjectAtThresholdDepth = undefined;\n  }\n  // This one actually may be worth to be moved to c++, we also need similar logic to run on the UI thread\n  const type = typeof value;\n  const isTypeObject = type === 'object';\n  const isTypeFunction = type === 'function';\n  if ((isTypeObject || isTypeFunction) && value !== null) {\n    const cached = _shareableCache.get(value);\n    if (cached === _shareableFlag) {\n      return value;\n    } else if (cached !== undefined) {\n      return cached as ShareableRef<T>;\n    } else {\n      let toAdapt: any;\n      if (Array.isArray(value)) {\n        toAdapt = value.map((element) =>\n          makeShareableCloneRecursive(element, shouldPersistRemote, depth + 1)\n        );\n      } else if (isTypeFunction && value.__workletHash === undefined) {\n        // this is a remote function\n        toAdapt = value;\n      } else if (isHostObject(value)) {\n        // for host objects we pass the reference to the object as shareable and\n        // then recreate new host object wrapping the same instance on the UI thread.\n        // there is no point of iterating over keys as we do for regular objects.\n        toAdapt = value;\n      } else if (isPlainJSObject(value) || isTypeFunction) {\n        toAdapt = {};\n        if (value.__workletHash !== undefined) {\n          // we are converting a worklet\n          if (__DEV__) {\n            if (value.__version !== jsVersion) {\n              throw new Error(`[Reanimated] Mismatch between JavaScript code version and Reanimated Babel plugin version (${jsVersion} vs. ${value.__version}). Please clear your Metro bundler cache with \\`yarn start --reset-cache\\`,\n              \\`npm start -- --reset-cache\\` or \\`expo start -c\\` and run the app again.`);\n            }\n            registerWorkletStackDetails(\n              value.__workletHash,\n              value.__stackDetails\n            );\n            delete value.__stackDetails;\n          }\n          // to save on transferring static __initData field of worklet structure\n          // we request shareable value to persist its UI counterpart. This means\n          // that the __initData field that contains long strings represeting the\n          // worklet code, source map, and location, will always be\n          // serialized/deserialized once.\n          toAdapt.__initData = makeShareableCloneRecursive(\n            value.__initData,\n            true,\n            depth + 1\n          );\n          delete value.__initData;\n        }\n\n        for (const [key, element] of Object.entries(value)) {\n          toAdapt[key] = makeShareableCloneRecursive(\n            element,\n            shouldPersistRemote,\n            depth + 1\n          );\n        }\n      } else {\n        // This is reached for object types that are not of plain Object.prototype.\n        // We don't support such objects from being transferred as shareables to\n        // the UI runtime and hence we replace them with \"inaccessible object\"\n        // which is implemented as a Proxy object that throws on any attempt\n        // of accessing its fields. We argue that such objects can sometimes leak\n        // as attributes of objects being captured by worklets but should never\n        // be used on the UI runtime regardless. If they are being accessed, the user\n        // will get an appropriate error message.\n        const inaccessibleObject =\n          makeShareableCloneRecursive<T>(INACCESSIBLE_OBJECT);\n        _shareableCache.set(value, inaccessibleObject);\n        return inaccessibleObject;\n      }\n      if (__DEV__) {\n        // we freeze objects that are transformed to shareable. This should help\n        // detect issues when someone modifies data after it's been converted to\n        // shareable. Meaning that they may be doing a faulty assumption in their\n        // code expecting that the updates are going to automatically populate to\n        // the object sent to the UI thread. If the user really wants some objects\n        // to be mutable they should use shared values instead.\n        Object.freeze(value);\n      }\n      const adopted = NativeReanimatedModule.makeShareableClone(\n        toAdapt,\n        shouldPersistRemote\n      );\n      _shareableCache.set(value, adopted);\n      _shareableCache.set(adopted, _shareableFlag);\n      return adopted;\n    }\n  }\n  return NativeReanimatedModule.makeShareableClone(value, shouldPersistRemote);\n}\n\nexport function makeShareableCloneOnUIRecursive<T>(value: T): ShareableRef<T> {\n  'worklet';\n  if (USE_STUB_IMPLEMENTATION) {\n    // @ts-ignore web is an interesting place where we don't run a secondary VM on the UI thread\n    // see more details in the comment where USE_STUB_IMPLEMENTATION is defined.\n    return value;\n  }\n  function cloneRecursive<T>(value: T): ShareableRef<T> {\n    const type = typeof value;\n    if ((type === 'object' || type === 'function') && value !== null) {\n      let toAdapt: any;\n      if (Array.isArray(value)) {\n        toAdapt = value.map((element) => cloneRecursive(element));\n      } else if (value !== undefined) {\n        toAdapt = {};\n        for (const [key, element] of Object.entries(value)) {\n          toAdapt[key] = cloneRecursive(element);\n        }\n      }\n      return _makeShareableClone(toAdapt);\n    }\n    return _makeShareableClone(value);\n  }\n  return cloneRecursive(value);\n}\n\nexport function makeShareable<T>(value: T): T {\n  if (USE_STUB_IMPLEMENTATION) {\n    return value;\n  }\n  const handle = makeShareableCloneRecursive({\n    __init: () => {\n      'worklet';\n      return value;\n    },\n  });\n  registerShareableMapping(value, handle);\n  return value;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}