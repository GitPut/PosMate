{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}import CircularBuffer from\"./CircularBuffer\";import LeastSquareSolver from\"./LeastSquareSolver\";var VelocityTracker=function(){function VelocityTracker(){_classCallCheck(this,VelocityTracker);_defineProperty(this,\"assumePointerMoveStoppedMilliseconds\",40);_defineProperty(this,\"historySize\",20);_defineProperty(this,\"horizonMilliseconds\",300);_defineProperty(this,\"minSampleSize\",3);_defineProperty(this,\"samples\",void 0);this.samples=new CircularBuffer(this.historySize);}_createClass(VelocityTracker,[{key:\"add\",value:function add(event){this.samples.push(event);}},{key:\"getVelocityEstimate\",value:function getVelocityEstimate(){var x=[];var y=[];var w=[];var time=[];var sampleCount=0;var index=this.samples.size-1;var newestSample=this.samples.get(index);if(!newestSample){return null;}var previousSample=newestSample;while(sampleCount<this.samples.size){var sample=this.samples.get(index);var age=newestSample.time-sample.time;var delta=Math.abs(sample.time-previousSample.time);previousSample=sample;if(age>this.horizonMilliseconds||delta>this.assumePointerMoveStoppedMilliseconds){break;}x.push(sample.x);y.push(sample.y);w.push(1);time.push(-age);sampleCount++;index--;}if(sampleCount>=this.minSampleSize){var xSolver=new LeastSquareSolver(time,x,w);var xFit=xSolver.solve(2);if(xFit!==null){var ySolver=new LeastSquareSolver(time,y,w);var yFit=ySolver.solve(2);if(yFit!==null){var xVelocity=xFit.coefficients[1]*1000;var yVelocity=yFit.coefficients[1]*1000;return[xVelocity,yVelocity];}}}return null;}},{key:\"getVelocity\",value:function getVelocity(){var estimate=this.getVelocityEstimate();if(estimate!==null){return estimate;}return[0,0];}},{key:\"reset\",value:function reset(){this.samples.clear();}}]);return VelocityTracker;}();export{VelocityTracker as default};","map":{"version":3,"mappings":"sTACA,MAAOA,eAAP,wBACA,MAAOC,kBAAP,8BAEqBC,gBAAN,YAQbC,0BAAc,mGAPiC,EAOjC,qCANQ,EAMR,6CALgB,GAKhB,uCAJU,CAIV,yCACZ,KAAKC,OAAL,CAAe,GAAIJ,eAAJ,CAAiC,KAAKK,WAAtC,CAAf,CACD,gDAEMC,aAAIC,KAAD,CAA4B,CACpC,KAAKH,OAAL,CAAaI,IAAb,CAAkBD,KAAlB,EACD,CAdkC,mCAsB3BE,8BAA+C,CACrD,GAAMC,EAAC,CAAG,EAAV,CACA,GAAMC,EAAC,CAAG,EAAV,CACA,GAAMC,EAAC,CAAG,EAAV,CACA,GAAMC,KAAI,CAAG,EAAb,CAEA,GAAIC,YAAW,CAAG,CAAlB,CACA,GAAIC,MAAK,CAAG,KAAKX,OAAL,CAAaY,IAAb,CAAoB,CAAhC,CACA,GAAMC,aAAY,CAAG,KAAKb,OAAL,CAAac,GAAb,CAAiBH,KAAjB,CAArB,CACA,GAAI,CAACE,YAAL,CAAmB,CACjB,MAAO,KAAP,CACD,CAED,GAAIE,eAAc,CAAGF,YAArB,CAIA,MAAOH,WAAW,CAAG,KAAKV,OAAL,CAAaY,IAAlC,CAAwC,CACtC,GAAMI,OAAM,CAAG,KAAKhB,OAAL,CAAac,GAAb,CAAiBH,KAAjB,CAAf,CAEA,GAAMM,IAAG,CAAGJ,YAAY,CAACJ,IAAb,CAAoBO,MAAM,CAACP,IAAvC,CACA,GAAMS,MAAK,CAAGC,IAAI,CAACC,GAAL,CAASJ,MAAM,CAACP,IAAP,CAAcM,cAAc,CAACN,IAAtC,CAAd,CACAM,cAAc,CAAGC,MAAjB,CAEA,GACEC,GAAG,CAAG,KAAKI,mBAAX,EACAH,KAAK,CAAG,KAAKI,oCAFf,CAGE,CACA,MACD,CAEDhB,CAAC,CAACF,IAAF,CAAOY,MAAM,CAACV,CAAd,EACAC,CAAC,CAACH,IAAF,CAAOY,MAAM,CAACT,CAAd,EACAC,CAAC,CAACJ,IAAF,CAAO,CAAP,EACAK,IAAI,CAACL,IAAL,CAAU,CAACa,GAAX,EAEAP,WAAW,GACXC,KAAK,GACN,CAED,GAAID,WAAW,EAAI,KAAKa,aAAxB,CAAuC,CACrC,GAAMC,QAAO,CAAG,GAAI3B,kBAAJ,CAAsBY,IAAtB,CAA4BH,CAA5B,CAA+BE,CAA/B,CAAhB,CACA,GAAMiB,KAAI,CAAGD,OAAO,CAACE,KAAR,CAAc,CAAd,CAAb,CAEA,GAAID,IAAI,GAAK,IAAb,CAAmB,CACjB,GAAME,QAAO,CAAG,GAAI9B,kBAAJ,CAAsBY,IAAtB,CAA4BF,CAA5B,CAA+BC,CAA/B,CAAhB,CACA,GAAMoB,KAAI,CAAGD,OAAO,CAACD,KAAR,CAAc,CAAd,CAAb,CAEA,GAAIE,IAAI,GAAK,IAAb,CAAmB,CACjB,GAAMC,UAAS,CAAGJ,IAAI,CAACK,YAAL,CAAkB,CAAlB,EAAuB,IAAzC,CACA,GAAMC,UAAS,CAAGH,IAAI,CAACE,YAAL,CAAkB,CAAlB,EAAuB,IAAzC,CAEA,MAAO,CAACD,SAAD,CAAYE,SAAZ,CAAP,CACD,CACF,CACF,CAED,MAAO,KAAP,CACD,4BAEMC,sBAAgC,CACrC,GAAMC,SAAQ,CAAG,KAAK5B,mBAAL,EAAjB,CACA,GAAI4B,QAAQ,GAAK,IAAjB,CAAuB,CACrB,MAAOA,SAAP,CACD,CACD,MAAO,CAAC,CAAD,CAAI,CAAJ,CAAP,CACD,sBAEMC,gBAAc,CACnB,KAAKlC,OAAL,CAAamC,KAAb,GACD,uCA5FkBrC,eAAN","names":["CircularBuffer","LeastSquareSolver","VelocityTracker","constructor","samples","historySize","add","event","push","getVelocityEstimate","x","y","w","time","sampleCount","index","size","newestSample","get","previousSample","sample","age","delta","Math","abs","horizonMilliseconds","assumePointerMoveStoppedMilliseconds","minSampleSize","xSolver","xFit","solve","ySolver","yFit","xVelocity","coefficients","yVelocity","getVelocity","estimate","reset","clear"],"sources":["/Users/peterputros/Desktop/PosMate/node_modules/react-native-gesture-handler/lib/module/web/tools/VelocityTracker.ts"],"sourcesContent":["import { AdaptedEvent } from '../interfaces';\nimport CircularBuffer from './CircularBuffer';\nimport LeastSquareSolver from './LeastSquareSolver';\n\nexport default class VelocityTracker {\n  private assumePointerMoveStoppedMilliseconds = 40;\n  private historySize = 20;\n  private horizonMilliseconds = 300;\n  private minSampleSize = 3;\n\n  private samples: CircularBuffer<AdaptedEvent>;\n\n  constructor() {\n    this.samples = new CircularBuffer<AdaptedEvent>(this.historySize);\n  }\n\n  public add(event: AdaptedEvent): void {\n    this.samples.push(event);\n  }\n\n  /// Returns an estimate of the velocity of the object being tracked by the\n  /// tracker given the current information available to the tracker.\n  ///\n  /// Information is added using [addPosition].\n  ///\n  /// Returns null if there is no data on which to base an estimate.\n  private getVelocityEstimate(): [number, number] | null {\n    const x = [];\n    const y = [];\n    const w = [];\n    const time = [];\n\n    let sampleCount = 0;\n    let index = this.samples.size - 1;\n    const newestSample = this.samples.get(index);\n    if (!newestSample) {\n      return null;\n    }\n\n    let previousSample = newestSample;\n\n    // Starting with the most recent PointAtTime sample, iterate backwards while\n    // the samples represent continuous motion.\n    while (sampleCount < this.samples.size) {\n      const sample = this.samples.get(index);\n\n      const age = newestSample.time - sample.time;\n      const delta = Math.abs(sample.time - previousSample.time);\n      previousSample = sample;\n\n      if (\n        age > this.horizonMilliseconds ||\n        delta > this.assumePointerMoveStoppedMilliseconds\n      ) {\n        break;\n      }\n\n      x.push(sample.x);\n      y.push(sample.y);\n      w.push(1);\n      time.push(-age);\n\n      sampleCount++;\n      index--;\n    }\n\n    if (sampleCount >= this.minSampleSize) {\n      const xSolver = new LeastSquareSolver(time, x, w);\n      const xFit = xSolver.solve(2);\n\n      if (xFit !== null) {\n        const ySolver = new LeastSquareSolver(time, y, w);\n        const yFit = ySolver.solve(2);\n\n        if (yFit !== null) {\n          const xVelocity = xFit.coefficients[1] * 1000;\n          const yVelocity = yFit.coefficients[1] * 1000;\n\n          return [xVelocity, yVelocity];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  public getVelocity(): [number, number] {\n    const estimate = this.getVelocityEstimate();\n    if (estimate !== null) {\n      return estimate;\n    }\n    return [0, 0];\n  }\n\n  public reset(): void {\n    this.samples.clear();\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}