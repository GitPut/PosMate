{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nvar _workletStackDetails = new Map();\nexport function registerWorkletStackDetails(hash, stackDetails) {\n  _workletStackDetails.set(hash, stackDetails);\n}\nfunction getBundleOffset(error) {\n  var _error$stack, _error$stack$split;\n  var frame = (_error$stack = error.stack) === null || _error$stack === void 0 ? void 0 : (_error$stack$split = _error$stack.split('\\n')) === null || _error$stack$split === void 0 ? void 0 : _error$stack$split[0];\n  if (frame) {\n    var parsedFrame = /@([^@]+):(\\d+):(\\d+)/.exec(frame);\n    if (parsedFrame) {\n      var _parsedFrame = _slicedToArray(parsedFrame, 4),\n        file = _parsedFrame[1],\n        line = _parsedFrame[2],\n        col = _parsedFrame[3];\n      return [file, Number(line), Number(col)];\n    }\n  }\n  return ['unknown', 0, 0];\n}\nfunction processStack(stack) {\n  var workletStackEntries = stack.match(/worklet_(\\d+):(\\d+):(\\d+)/g);\n  var result = stack;\n  workletStackEntries === null || workletStackEntries === void 0 ? void 0 : workletStackEntries.forEach(function (match) {\n    var _match$split$map = match.split(/:|_/).map(Number),\n      _match$split$map2 = _slicedToArray(_match$split$map, 4),\n      hash = _match$split$map2[1],\n      origLine = _match$split$map2[2],\n      origCol = _match$split$map2[3];\n    var errorDetails = _workletStackDetails.get(hash);\n    if (!errorDetails) {\n      return;\n    }\n    var _errorDetails = _slicedToArray(errorDetails, 3),\n      error = _errorDetails[0],\n      lineOffset = _errorDetails[1],\n      colOffset = _errorDetails[2];\n    var _getBundleOffset = getBundleOffset(error),\n      _getBundleOffset2 = _slicedToArray(_getBundleOffset, 3),\n      bundleFile = _getBundleOffset2[0],\n      bundleLine = _getBundleOffset2[1],\n      bundleCol = _getBundleOffset2[2];\n    var line = origLine + bundleLine + lineOffset;\n    var col = origCol + bundleCol + colOffset;\n    result = result.replace(match, `${bundleFile}:${line}:${col}`);\n  });\n  return result;\n}\nexport function reportFatalErrorOnJS(_ref) {\n  var message = _ref.message,\n    stack = _ref.stack;\n  var error = new Error();\n  error.message = message;\n  error.stack = stack ? processStack(stack) : undefined;\n  error.name = 'ReanimatedError';\n  error.jsEngine = 'reanimated';\n  global.ErrorUtils.reportFatalError(error);\n}","map":{"version":3,"mappings":";AAEA,IAAMA,oBAAoB,GAAG,IAAIC,GAAG,EAAwB;AAE5D,OAAO,SAASC,2BAA2BA,CACzCC,IAAY,EACZC,YAA0B,EAC1B;EACAJ,oBAAoB,CAACK,GAAG,CAACF,IAAI,EAAEC,YAAY,CAAC;AAC9C;AAEA,SAASE,eAAeA,CAACC,KAAY,EAA4B;EAAA;EAC/D,IAAMC,KAAK,mBAAGD,KAAK,CAACE,KAAK,uEAAXC,aAAaC,KAAK,CAAC,IAAI,CAAC,uDAAxBC,mBAA2B,CAAC,CAAC;EAC3C,IAAIJ,KAAK,EAAE;IACT,IAAMK,WAAW,GAAG,sBAAsB,CAACC,IAAI,CAACN,KAAK,CAAC;IACtD,IAAIK,WAAW,EAAE;MACf,kCAA4BA,WAAW;QAA9BE,IAAI;QAAEC,IAAI;QAAEC,GAAG;MACxB,OAAO,CAACF,IAAI,EAAEG,MAAM,CAACF,IAAI,CAAC,EAAEE,MAAM,CAACD,GAAG,CAAC,CAAC;IAC1C;EACF;EACA,OAAO,CAAC,SAAS,EAAE,CAAC,EAAE,CAAC,CAAC;AAC1B;AAEA,SAASE,YAAYA,CAACV,KAAa,EAAU;EAC3C,IAAMW,mBAAmB,GAAGX,KAAK,CAACY,KAAK,CAAC,4BAA4B,CAAC;EACrE,IAAIC,MAAM,GAAGb,KAAK;EAClBW,mBAAmB,aAAnBA,mBAAmB,uBAAnBA,mBAAmB,CAAEG,OAAO,CAAEF,eAAK,EAAK;IACtC,uBAAoCA,KAAK,CAACV,KAAK,CAAC,KAAK,CAAC,CAACa,GAAG,CAACN,MAAM,CAAC;MAAA;MAAzDf,IAAI;MAAEsB,QAAQ;MAAEC,OAAO;IAChC,IAAMC,YAAY,GAAG3B,oBAAoB,CAAC4B,GAAG,CAACzB,IAAI,CAAC;IACnD,IAAI,CAACwB,YAAY,EAAE;MACjB;IACF;IACA,mCAAuCA,YAAY;MAA5CpB,KAAK;MAAEsB,UAAU;MAAEC,SAAS;IACnC,uBAA4CxB,eAAe,CAACC,KAAK,CAAC;MAAA;MAA3DwB,UAAU;MAAEC,UAAU;MAAEC,SAAS;IACxC,IAAMjB,IAAI,GAAGS,QAAQ,GAAGO,UAAU,GAAGH,UAAU;IAC/C,IAAMZ,GAAG,GAAGS,OAAO,GAAGO,SAAS,GAAGH,SAAS;IAE3CR,MAAM,GAAGA,MAAM,CAACY,OAAO,CAACb,KAAK,EAAG,GAAEU,UAAW,IAAGf,IAAK,IAAGC,GAAI,EAAC,CAAC;EAChE,CAAC,CAAC;EACF,OAAOK,MAAM;AACf;AAEA,OAAO,SAASa,oBAAoBA,OAMjC;EAAA,IALDC,OAAO,GAKRC,KALCD,OAAO;IACP3B,QAID4B,KAJC5B;EAKA,IAAMF,KAAK,GAAG,IAAI+B,KAAK,EAAE;EACzB/B,KAAK,CAAC6B,OAAO,GAAGA,OAAO;EACvB7B,KAAK,CAACE,KAAK,GAAGA,KAAK,GAAGU,YAAY,CAACV,KAAK,CAAC,GAAG8B,SAAS;EACrDhC,KAAK,CAACiC,IAAI,GAAG,iBAAiB;EAE9BjC,KAAK,CAACkC,QAAQ,GAAG,YAAY;EAE7BC,MAAM,CAACC,UAAU,CAACC,gBAAgB,CAACrC,KAAK,CAAC;AAC3C","names":["_workletStackDetails","Map","registerWorkletStackDetails","hash","stackDetails","set","getBundleOffset","error","frame","stack","_error$stack","split","_error$stack$split","parsedFrame","exec","file","line","col","Number","processStack","workletStackEntries","match","result","forEach","map","origLine","origCol","errorDetails","get","lineOffset","colOffset","bundleFile","bundleLine","bundleCol","replace","reportFatalErrorOnJS","message","_ref","Error","undefined","name","jsEngine","global","ErrorUtils","reportFatalError"],"sources":["/Users/georgebadal/Desktop/PosMate/node_modules/react-native-reanimated/lib/module/reanimated2/errors.ts"],"sourcesContent":["type StackDetails = [Error, number, number];\n\nconst _workletStackDetails = new Map<number, StackDetails>();\n\nexport function registerWorkletStackDetails(\n  hash: number,\n  stackDetails: StackDetails\n) {\n  _workletStackDetails.set(hash, stackDetails);\n}\n\nfunction getBundleOffset(error: Error): [string, number, number] {\n  const frame = error.stack?.split('\\n')?.[0];\n  if (frame) {\n    const parsedFrame = /@([^@]+):(\\d+):(\\d+)/.exec(frame);\n    if (parsedFrame) {\n      const [, file, line, col] = parsedFrame;\n      return [file, Number(line), Number(col)];\n    }\n  }\n  return ['unknown', 0, 0];\n}\n\nfunction processStack(stack: string): string {\n  const workletStackEntries = stack.match(/worklet_(\\d+):(\\d+):(\\d+)/g);\n  let result = stack;\n  workletStackEntries?.forEach((match) => {\n    const [, hash, origLine, origCol] = match.split(/:|_/).map(Number);\n    const errorDetails = _workletStackDetails.get(hash);\n    if (!errorDetails) {\n      return;\n    }\n    const [error, lineOffset, colOffset] = errorDetails;\n    const [bundleFile, bundleLine, bundleCol] = getBundleOffset(error);\n    const line = origLine + bundleLine + lineOffset;\n    const col = origCol + bundleCol + colOffset;\n\n    result = result.replace(match, `${bundleFile}:${line}:${col}`);\n  });\n  return result;\n}\n\nexport function reportFatalErrorOnJS({\n  message,\n  stack,\n}: {\n  message: string;\n  stack?: string;\n}) {\n  const error = new Error();\n  error.message = message;\n  error.stack = stack ? processStack(stack) : undefined;\n  error.name = 'ReanimatedError';\n  // @ts-ignore React Native's ErrorUtils implementation extends the Error type with jsEngine field\n  error.jsEngine = 'reanimated';\n  // @ts-ignore the reportFatalError method is an internal method of ErrorUtils not exposed in the type definitions\n  global.ErrorUtils.reportFatalError(error);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}