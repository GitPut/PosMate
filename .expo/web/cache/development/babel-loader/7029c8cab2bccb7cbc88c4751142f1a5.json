{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    keys.push.apply(keys, Object.getOwnPropertySymbols(object));\n  }\n  if (enumerableOnly) keys = keys.filter(function (sym) {\n    return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n  });\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { useState, useContext, useEffect, useLayoutEffect, useRef, useCallback } from 'react';\nimport { NavigationContext } from 'react-navigation';\nexport function useNavigation() {\n  var navigation = useContext(NavigationContext);\n  if (!navigation) {\n    throw new Error(\"react-navigation hooks require a navigation context but it couldn't be found. \" + \"Make sure you didn't forget to create and render the react-navigation app container. \" + 'If you need to access an optional navigation object, you can useContext(NavigationContext), which may return');\n  }\n  return navigation;\n}\nexport function useNavigationParam(paramName) {\n  return useNavigation().getParam(paramName);\n}\nexport function useNavigationState() {\n  return useNavigation().state;\n}\nexport function useNavigationKey() {\n  return useNavigation().state.key;\n}\nvar useGetter = function useGetter(value) {\n  var ref = useRef(value);\n  useLayoutEffect(function () {\n    ref.current = value;\n  });\n  return useCallback(function () {\n    return ref.current;\n  }, [ref]);\n};\nexport function useNavigationEvents(callback) {\n  var navigation = useNavigation();\n  var getLatestCallback = useGetter(callback);\n  useLayoutEffect(function () {\n    var subscribedCallback = function subscribedCallback(event) {\n      var latestCallback = getLatestCallback();\n      latestCallback(event);\n    };\n    var subs = [navigation.addListener('action', subscribedCallback), navigation.addListener('willFocus', subscribedCallback), navigation.addListener('didFocus', subscribedCallback), navigation.addListener('willBlur', subscribedCallback), navigation.addListener('didBlur', subscribedCallback)];\n    return function () {\n      subs.forEach(function (sub) {\n        return sub.remove();\n      });\n    };\n  }, [navigation.state.key]);\n}\nvar emptyFocusState = {\n  isFocused: false,\n  isBlurring: false,\n  isBlurred: false,\n  isFocusing: false\n};\nvar didFocusState = _objectSpread({}, emptyFocusState, {\n  isFocused: true\n});\nvar willBlurState = _objectSpread({}, emptyFocusState, {\n  isBlurring: true\n});\nvar didBlurState = _objectSpread({}, emptyFocusState, {\n  isBlurred: true\n});\nvar willFocusState = _objectSpread({}, emptyFocusState, {\n  isFocusing: true\n});\nfunction nextFocusState(eventName, currentState) {\n  switch (eventName) {\n    case 'willFocus':\n      return _objectSpread({}, willFocusState, {\n        isFocused: currentState.isFocused\n      });\n    case 'didFocus':\n      return didFocusState;\n    case 'willBlur':\n      return willBlurState;\n    case 'didBlur':\n      return didBlurState;\n    default:\n      return currentState;\n  }\n}\nexport function useFocusState() {\n  var navigation = useNavigation();\n  var _useState = useState(function () {\n      return navigation.isFocused() ? didFocusState : didBlurState;\n    }),\n    _useState2 = _slicedToArray(_useState, 2),\n    focusState = _useState2[0],\n    setFocusState = _useState2[1];\n  useNavigationEvents(function (e) {\n    setFocusState(function (currentFocusState) {\n      return nextFocusState(e.type, currentFocusState);\n    });\n  });\n  return focusState;\n}\nexport var useFocusEffect = function useFocusEffect(callback) {\n  var navigation = useNavigation();\n  useEffect(function () {\n    var isFocused = false;\n    var cleanup;\n    if (navigation.isFocused()) {\n      cleanup = callback();\n      isFocused = true;\n    }\n    var focusSubscription = navigation.addListener('willFocus', function () {\n      if (isFocused) {\n        return;\n      }\n      cleanup && cleanup();\n      cleanup = callback();\n      isFocused = true;\n    });\n    var blurSubscription = navigation.addListener('willBlur', function () {\n      cleanup && cleanup();\n      cleanup = undefined;\n      isFocused = false;\n    });\n    return function () {\n      cleanup && cleanup();\n      focusSubscription.remove();\n      blurSubscription.remove();\n    };\n  }, [callback, navigation]);\n};\nexport var useIsFocused = function useIsFocused() {\n  var navigation = useNavigation();\n  var getNavigation = useGetter(navigation);\n  var _useState3 = useState(navigation.isFocused),\n    _useState4 = _slicedToArray(_useState3, 2),\n    focused = _useState4[0],\n    setFocused = _useState4[1];\n  useEffect(function () {\n    var nav = getNavigation();\n    var focusSubscription = nav.addListener('willFocus', function () {\n      return setFocused(true);\n    });\n    var blurSubscription = nav.addListener('willBlur', function () {\n      return setFocused(false);\n    });\n    return function () {\n      focusSubscription.remove();\n      blurSubscription.remove();\n    };\n  }, [getNavigation]);\n  return focused;\n};","map":{"version":3,"mappings":"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","names":["useState","useContext","useEffect","useLayoutEffect","useRef","useCallback","NavigationContext","useNavigation","navigation","Error","useNavigationParam","paramName","getParam","useNavigationState","state","useNavigationKey","key","useGetter","value","ref","current","useNavigationEvents","callback","getLatestCallback","subscribedCallback","latestCallback","event","subs","addListener","forEach","sub","remove","emptyFocusState","isFocused","isBlurring","isBlurred","isFocusing","didFocusState","willBlurState","didBlurState","willFocusState","nextFocusState","eventName","currentState","useFocusState","_useState2","focusState","setFocusState","e","type","currentFocusState","useFocusEffect","cleanup","focusSubscription","blurSubscription","undefined","useIsFocused","getNavigation","_useState4","focused","setFocused","nav"],"sources":["Hooks.ts"],"sourcesContent":["import {\n  useState,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useCallback,\n} from 'react';\n\nimport {\n  NavigationContext,\n  NavigationScreenProp,\n  NavigationRoute,\n  NavigationParams,\n  NavigationEventCallback,\n  NavigationEventPayload,\n  EventType,\n} from 'react-navigation';\n\nexport function useNavigation<S>(): NavigationScreenProp<S & NavigationRoute> {\n  const navigation = useContext(NavigationContext) as any; // TODO typing?\n  if (!navigation) {\n    throw new Error(\n      \"react-navigation hooks require a navigation context but it couldn't be found. \" +\n        \"Make sure you didn't forget to create and render the react-navigation app container. \" +\n        'If you need to access an optional navigation object, you can useContext(NavigationContext), which may return'\n    );\n  }\n  return navigation;\n}\n\nexport function useNavigationParam<T extends keyof NavigationParams>(\n  paramName: T\n) {\n  return useNavigation().getParam(paramName);\n}\n\nexport function useNavigationState() {\n  return useNavigation().state;\n}\n\nexport function useNavigationKey() {\n  return useNavigation().state.key;\n}\n\n// Useful to access the latest user-provided value\nconst useGetter = <S>(value: S): (() => S) => {\n  const ref = useRef(value);\n  useLayoutEffect(() => {\n    ref.current = value;\n  });\n  return useCallback(() => ref.current, [ref]);\n};\n\nexport function useNavigationEvents(callback: NavigationEventCallback) {\n  const navigation = useNavigation();\n\n  // Closure might change over time and capture some variables\n  // It's important to fire the latest closure provided by the user\n  const getLatestCallback = useGetter(callback);\n\n  // It's important to useLayoutEffect because we want to ensure we subscribe synchronously to the mounting\n  // of the component, similarly to what would happen if we did use componentDidMount\n  // (that we use in <NavigationEvents/>)\n  // When mounting/focusing a new screen and subscribing to focus, the focus event should be fired\n  // It wouldn't fire if we did subscribe with useEffect()\n  useLayoutEffect(() => {\n    const subscribedCallback: NavigationEventCallback = event => {\n      const latestCallback = getLatestCallback();\n      latestCallback(event);\n    };\n\n    const subs = [\n      // TODO should we remove \"action\" here? it's not in the published typedefs\n      navigation.addListener('action' as any, subscribedCallback),\n      navigation.addListener('willFocus', subscribedCallback),\n      navigation.addListener('didFocus', subscribedCallback),\n      navigation.addListener('willBlur', subscribedCallback),\n      navigation.addListener('didBlur', subscribedCallback),\n    ];\n    return () => {\n      subs.forEach(sub => sub.remove());\n    };\n  }, [navigation.state.key]);\n}\n\nexport interface FocusState {\n  isFocused: boolean;\n  isBlurring: boolean;\n  isBlurred: boolean;\n  isFocusing: boolean;\n}\n\nconst emptyFocusState: FocusState = {\n  isFocused: false,\n  isBlurring: false,\n  isBlurred: false,\n  isFocusing: false,\n};\nconst didFocusState: FocusState = { ...emptyFocusState, isFocused: true };\nconst willBlurState: FocusState = { ...emptyFocusState, isBlurring: true };\nconst didBlurState: FocusState = { ...emptyFocusState, isBlurred: true };\nconst willFocusState: FocusState = { ...emptyFocusState, isFocusing: true };\n\nfunction nextFocusState(\n  eventName: EventType,\n  currentState: FocusState\n): FocusState {\n  switch (eventName) {\n    case 'willFocus':\n      return {\n        ...willFocusState,\n        // /!\\ willFocus will fire on screen mount, while the screen is already marked as focused.\n        // In case of a new screen mounted/focused, we want to avoid a isFocused = true => false => true transition\n        // So we don't put the \"false\" here and ensure the attribute remains as before\n        // Currently I think the behavior of the event system on mount is not very well specified\n        // See also https://twitter.com/sebastienlorber/status/1166986080966578176\n        isFocused: currentState.isFocused,\n      };\n    case 'didFocus':\n      return didFocusState;\n    case 'willBlur':\n      return willBlurState;\n    case 'didBlur':\n      return didBlurState;\n    default:\n      // preserve current state for other events (\"action\"?)\n      return currentState;\n  }\n}\n\nexport function useFocusState() {\n  const navigation = useNavigation();\n\n  const [focusState, setFocusState] = useState<FocusState>(() => {\n    return navigation.isFocused() ? didFocusState : didBlurState;\n  });\n\n  useNavigationEvents((e: NavigationEventPayload) => {\n    setFocusState(currentFocusState =>\n      nextFocusState(e.type, currentFocusState)\n    );\n  });\n\n  return focusState;\n}\n\ntype EffectCallback = (() => void) | (() => () => void);\n\n// Inspired by same hook from react-navigation v5\n// See https://github.com/react-navigation/hooks/issues/39#issuecomment-534694135\nexport const useFocusEffect = (callback: EffectCallback) => {\n  const navigation = useNavigation();\n\n  useEffect(() => {\n    let isFocused = false;\n    let cleanup: (() => void) | void;\n\n    if (navigation.isFocused()) {\n      cleanup = callback();\n      isFocused = true;\n    }\n\n    const focusSubscription = navigation.addListener('willFocus', () => {\n      // If callback was already called for focus, avoid calling it again\n      // The focus event may also fire on intial render, so we guard against runing the effect twice\n      if (isFocused) {\n        return;\n      }\n\n      cleanup && cleanup();\n      cleanup = callback();\n      isFocused = true;\n    });\n\n    const blurSubscription = navigation.addListener('willBlur', () => {\n      cleanup && cleanup();\n      cleanup = undefined;\n      isFocused = false;\n    });\n\n    return () => {\n      cleanup && cleanup();\n      focusSubscription.remove();\n      blurSubscription.remove();\n    };\n  }, [callback, navigation]);\n};\n\nexport const useIsFocused = () => {\n  const navigation = useNavigation();\n  const getNavigation = useGetter(navigation);\n  const [focused, setFocused] = useState(navigation.isFocused);\n\n  useEffect(() => {\n    const nav = getNavigation();\n    const focusSubscription = nav.addListener('willFocus', () =>\n      setFocused(true)\n    );\n    const blurSubscription = nav.addListener('willBlur', () =>\n      setFocused(false)\n    );\n    return () => {\n      focusSubscription.remove();\n      blurSubscription.remove();\n    };\n  }, [getNavigation]);\n\n  return focused;\n};\n"]},"metadata":{},"sourceType":"module"}