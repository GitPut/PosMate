{"ast":null,"code":"\n\n(function ($) {\n  $.color = {};\n  $.color.make = function (r, g, b, a) {\n    var o = {};\n    o.r = r || 0;\n    o.g = g || 0;\n    o.b = b || 0;\n    o.a = a != null ? a : 1;\n    o.add = function (c, d) {\n      for (var i = 0; i < c.length; ++i) {\n        o[c.charAt(i)] += d;\n      }\n      return o.normalize();\n    };\n    o.scale = function (c, f) {\n      for (var i = 0; i < c.length; ++i) {\n        o[c.charAt(i)] *= f;\n      }\n      return o.normalize();\n    };\n    o.toString = function () {\n      if (o.a >= 1) {\n        return \"rgb(\" + [o.r, o.g, o.b].join(\",\") + \")\";\n      } else {\n        return \"rgba(\" + [o.r, o.g, o.b, o.a].join(\",\") + \")\";\n      }\n    };\n    o.normalize = function () {\n      function clamp(min, value, max) {\n        return value < min ? min : value > max ? max : value;\n      }\n      o.r = clamp(0, parseInt(o.r), 255);\n      o.g = clamp(0, parseInt(o.g), 255);\n      o.b = clamp(0, parseInt(o.b), 255);\n      o.a = clamp(0, o.a, 1);\n      return o;\n    };\n    o.clone = function () {\n      return $.color.make(o.r, o.b, o.g, o.a);\n    };\n    return o.normalize();\n  };\n  $.color.extract = function (elem, css) {\n    var c;\n    do {\n      c = elem.css(css).toLowerCase();\n      if (c != \"\" && c != \"transparent\") break;\n      elem = elem.parent();\n    } while (elem.length && !$.nodeName(elem.get(0), \"body\"));\n    if (c == \"rgba(0, 0, 0, 0)\") c = \"transparent\";\n    return $.color.parse(c);\n  };\n  $.color.parse = function (str) {\n    var res,\n      m = $.color.make;\n    if (res = /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/.exec(str)) return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10));\n    if (res = /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str)) return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10), parseFloat(res[4]));\n    if (res = /rgb\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*\\)/.exec(str)) return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55);\n    if (res = /rgba\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str)) return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55, parseFloat(res[4]));\n    if (res = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str)) return m(parseInt(res[1], 16), parseInt(res[2], 16), parseInt(res[3], 16));\n    if (res = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str)) return m(parseInt(res[1] + res[1], 16), parseInt(res[2] + res[2], 16), parseInt(res[3] + res[3], 16));\n    var name = $.trim(str).toLowerCase();\n    if (name == \"transparent\") return m(255, 255, 255, 0);else {\n      res = lookupColors[name] || [0, 0, 0];\n      return m(res[0], res[1], res[2]);\n    }\n  };\n  var lookupColors = {\n    aqua: [0, 255, 255],\n    azure: [240, 255, 255],\n    beige: [245, 245, 220],\n    black: [0, 0, 0],\n    blue: [0, 0, 255],\n    brown: [165, 42, 42],\n    cyan: [0, 255, 255],\n    darkblue: [0, 0, 139],\n    darkcyan: [0, 139, 139],\n    darkgrey: [169, 169, 169],\n    darkgreen: [0, 100, 0],\n    darkkhaki: [189, 183, 107],\n    darkmagenta: [139, 0, 139],\n    darkolivegreen: [85, 107, 47],\n    darkorange: [255, 140, 0],\n    darkorchid: [153, 50, 204],\n    darkred: [139, 0, 0],\n    darksalmon: [233, 150, 122],\n    darkviolet: [148, 0, 211],\n    fuchsia: [255, 0, 255],\n    gold: [255, 215, 0],\n    green: [0, 128, 0],\n    indigo: [75, 0, 130],\n    khaki: [240, 230, 140],\n    lightblue: [173, 216, 230],\n    lightcyan: [224, 255, 255],\n    lightgreen: [144, 238, 144],\n    lightgrey: [211, 211, 211],\n    lightpink: [255, 182, 193],\n    lightyellow: [255, 255, 224],\n    lime: [0, 255, 0],\n    magenta: [255, 0, 255],\n    maroon: [128, 0, 0],\n    navy: [0, 0, 128],\n    olive: [128, 128, 0],\n    orange: [255, 165, 0],\n    pink: [255, 192, 203],\n    purple: [128, 0, 128],\n    violet: [128, 0, 128],\n    red: [255, 0, 0],\n    silver: [192, 192, 192],\n    white: [255, 255, 255],\n    yellow: [255, 255, 0]\n  };\n})(jQuery);\n\n(function ($) {\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  if (!$.fn.detach) {\n    $.fn.detach = function () {\n      return this.each(function () {\n        if (this.parentNode) {\n          this.parentNode.removeChild(this);\n        }\n      });\n    };\n  }\n\n  function Canvas(cls, container) {\n    var element = container.children(\".\" + cls)[0];\n    if (element == null) {\n      element = document.createElement(\"canvas\");\n      element.className = cls;\n      $(element).css({\n        direction: \"ltr\",\n        position: \"absolute\",\n        left: 0,\n        top: 0\n      }).appendTo(container);\n\n      if (!element.getContext) {\n        if (window.G_vmlCanvasManager) {\n          element = window.G_vmlCanvasManager.initElement(element);\n        } else {\n          throw new Error(\"Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.\");\n        }\n      }\n    }\n    this.element = element;\n    var context = this.context = element.getContext(\"2d\");\n\n    var devicePixelRatio = window.devicePixelRatio || 1,\n      backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n    this.pixelRatio = devicePixelRatio / backingStoreRatio;\n\n    this.resize(container.width(), container.height());\n\n    this.textContainer = null;\n    this.text = {};\n\n    this._textCache = {};\n  }\n\n  Canvas.prototype.resize = function (width, height) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid dimensions for plot, width = \" + width + \", height = \" + height);\n    }\n    var element = this.element,\n      context = this.context,\n      pixelRatio = this.pixelRatio;\n\n    if (this.width != width) {\n      element.width = width * pixelRatio;\n      element.style.width = width + \"px\";\n      this.width = width;\n    }\n    if (this.height != height) {\n      element.height = height * pixelRatio;\n      element.style.height = height + \"px\";\n      this.height = height;\n    }\n\n    context.restore();\n    context.save();\n\n    context.scale(pixelRatio, pixelRatio);\n  };\n\n  Canvas.prototype.clear = function () {\n    this.context.clearRect(0, 0, this.width, this.height);\n  };\n\n  Canvas.prototype.render = function () {\n    var cache = this._textCache;\n\n    for (var layerKey in cache) {\n      if (hasOwnProperty.call(cache, layerKey)) {\n        var layer = this.getTextLayer(layerKey),\n          layerCache = cache[layerKey];\n        layer.hide();\n        for (var styleKey in layerCache) {\n          if (hasOwnProperty.call(layerCache, styleKey)) {\n            var styleCache = layerCache[styleKey];\n            for (var key in styleCache) {\n              if (hasOwnProperty.call(styleCache, key)) {\n                var positions = styleCache[key].positions;\n                for (var i = 0, position; position = positions[i]; i++) {\n                  if (position.active) {\n                    if (!position.rendered) {\n                      layer.append(position.element);\n                      position.rendered = true;\n                    }\n                  } else {\n                    positions.splice(i--, 1);\n                    if (position.rendered) {\n                      position.element.detach();\n                    }\n                  }\n                }\n                if (positions.length == 0) {\n                  delete styleCache[key];\n                }\n              }\n            }\n          }\n        }\n        layer.show();\n      }\n    }\n  };\n\n  Canvas.prototype.getTextLayer = function (classes) {\n    var layer = this.text[classes];\n\n    if (layer == null) {\n\n      if (this.textContainer == null) {\n        this.textContainer = $(\"<div class='flot-text'></div>\").css({\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          bottom: 0,\n          right: 0,\n          'font-size': \"smaller\",\n          color: \"#545454\"\n        }).insertAfter(this.element);\n      }\n      layer = this.text[classes] = $(\"<div></div>\").addClass(classes).css({\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0\n      }).appendTo(this.textContainer);\n    }\n    return layer;\n  };\n\n  Canvas.prototype.getTextInfo = function (layer, text, font, angle, width) {\n    var textStyle, layerCache, styleCache, info;\n\n    text = \"\" + text;\n\n    if (typeof font === \"object\") {\n      textStyle = font.style + \" \" + font.variant + \" \" + font.weight + \" \" + font.size + \"px/\" + font.lineHeight + \"px \" + font.family;\n    } else {\n      textStyle = font;\n    }\n\n    layerCache = this._textCache[layer];\n    if (layerCache == null) {\n      layerCache = this._textCache[layer] = {};\n    }\n    styleCache = layerCache[textStyle];\n    if (styleCache == null) {\n      styleCache = layerCache[textStyle] = {};\n    }\n    info = styleCache[text];\n\n    if (info == null) {\n      var element = $(\"<div></div>\").html(text).css({\n        position: \"absolute\",\n        'max-width': width,\n        top: -9999\n      }).appendTo(this.getTextLayer(layer));\n      if (typeof font === \"object\") {\n        element.css({\n          font: textStyle,\n          color: font.color\n        });\n      } else if (typeof font === \"string\") {\n        element.addClass(font);\n      }\n      info = styleCache[text] = {\n        width: element.outerWidth(true),\n        height: element.outerHeight(true),\n        element: element,\n        positions: []\n      };\n      element.detach();\n    }\n    return info;\n  };\n\n  Canvas.prototype.addText = function (layer, x, y, text, font, angle, width, halign, valign) {\n    var info = this.getTextInfo(layer, text, font, angle, width),\n      positions = info.positions;\n\n    if (halign == \"center\") {\n      x -= info.width / 2;\n    } else if (halign == \"right\") {\n      x -= info.width;\n    }\n    if (valign == \"middle\") {\n      y -= info.height / 2;\n    } else if (valign == \"bottom\") {\n      y -= info.height;\n    }\n\n    for (var i = 0, position; position = positions[i]; i++) {\n      if (position.x == x && position.y == y) {\n        position.active = true;\n        return;\n      }\n    }\n\n    position = {\n      active: true,\n      rendered: false,\n      element: positions.length ? info.element.clone() : info.element,\n      x: x,\n      y: y\n    };\n    positions.push(position);\n\n    position.element.css({\n      top: Math.round(y),\n      left: Math.round(x),\n      'text-align': halign\n    });\n  };\n\n  Canvas.prototype.removeText = function (layer, x, y, text, font, angle) {\n    if (text == null) {\n      var layerCache = this._textCache[layer];\n      if (layerCache != null) {\n        for (var styleKey in layerCache) {\n          if (hasOwnProperty.call(layerCache, styleKey)) {\n            var styleCache = layerCache[styleKey];\n            for (var key in styleCache) {\n              if (hasOwnProperty.call(styleCache, key)) {\n                var positions = styleCache[key].positions;\n                for (var i = 0, position; position = positions[i]; i++) {\n                  position.active = false;\n                }\n              }\n            }\n          }\n        }\n      }\n    } else {\n      var positions = this.getTextInfo(layer, text, font, angle).positions;\n      for (var i = 0, position; position = positions[i]; i++) {\n        if (position.x == x && position.y == y) {\n          position.active = false;\n        }\n      }\n    }\n  };\n\n  function Plot(placeholder, data_, options_, plugins) {\n\n    var series = [],\n      options = {\n        colors: [\"#fa057a\", \"#f72d66\", \"#f7be2d\", \"#2dcbf7\", \"#64E572\"],\n        legend: {\n          show: true,\n          noColumns: 1,\n          labelFormatter: null,\n          labelBoxBorderColor: \"transparent\",\n          container: null,\n          position: \"ne\",\n          margin: 5,\n          backgroundColor: null,\n          backgroundOpacity: 0.85,\n          sorted: null\n        },\n\n        xaxis: {\n          show: null,\n          position: \"bottom\",\n          mode: null,\n          font: null,\n          color: null,\n          tickColor: null,\n          transform: null,\n          inverseTransform: null,\n          min: null,\n          max: null,\n          autoscaleMargin: null,\n          ticks: null,\n          tickFormatter: null,\n          labelWidth: null,\n          labelHeight: null,\n          reserveSpace: null,\n          tickLength: null,\n          alignTicksWithAxis: null,\n          tickDecimals: null,\n          tickSize: null,\n          minTickSize: null\n        },\n\n        yaxis: {\n          autoscaleMargin: 0.02,\n          position: \"left\"\n        },\n\n        xaxes: [],\n        yaxes: [],\n        series: {\n          points: {\n            show: false,\n            radius: 3,\n            lineWidth: 2,\n            fill: true,\n            fillColor: \"#ffffff\",\n            symbol: \"circle\"\n          },\n\n          lines: {\n            lineWidth: 2,\n            fill: false,\n            fillColor: null,\n            steps: false\n          },\n\n          bars: {\n            show: false,\n            lineWidth: 2,\n            barWidth: 1,\n            fill: true,\n            fillColor: null,\n            align: \"left\",\n            horizontal: false,\n            zero: true\n          },\n          shadowSize: 3,\n          highlightColor: null\n        },\n        grid: {\n          show: true,\n          aboveData: false,\n          color: \"#545454\",\n          backgroundColor: null,\n          borderColor: \"#eef0f2\",\n          tickColor: null,\n          margin: 0,\n          labelMargin: 5,\n          axisMargin: 8,\n          borderWidth: 0,\n          minBorderMargin: null,\n          markings: null,\n          markingsColor: \"#f4f4f4\",\n          markingsLineWidth: 2,\n          clickable: false,\n          hoverable: false,\n          autoHighlight: true,\n          mouseActiveRadius: 10\n        },\n\n        interaction: {\n          redrawOverlayInterval: 1000 / 60\n        },\n\n        hooks: {}\n      },\n      surface = null,\n      overlay = null,\n      eventHolder = null,\n      ctx = null,\n      octx = null,\n      xaxes = [],\n      yaxes = [],\n      plotOffset = {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      },\n      plotWidth = 0,\n      plotHeight = 0,\n      hooks = {\n        processOptions: [],\n        processRawData: [],\n        processDatapoints: [],\n        processOffset: [],\n        drawBackground: [],\n        drawSeries: [],\n        draw: [],\n        bindEvents: [],\n        drawOverlay: [],\n        shutdown: []\n      },\n      plot = this;\n\n    plot.setData = setData;\n    plot.setupGrid = setupGrid;\n    plot.draw = draw;\n    plot.getPlaceholder = function () {\n      return placeholder;\n    };\n    plot.getCanvas = function () {\n      return surface.element;\n    };\n    plot.getPlotOffset = function () {\n      return plotOffset;\n    };\n    plot.width = function () {\n      return plotWidth;\n    };\n    plot.height = function () {\n      return plotHeight;\n    };\n    plot.offset = function () {\n      var o = eventHolder.offset();\n      o.left += plotOffset.left;\n      o.top += plotOffset.top;\n      return o;\n    };\n    plot.getData = function () {\n      return series;\n    };\n    plot.getAxes = function () {\n      var res = {},\n        i;\n      $.each(xaxes.concat(yaxes), function (_, axis) {\n        if (axis) res[axis.direction + (axis.n != 1 ? axis.n : \"\") + \"axis\"] = axis;\n      });\n      return res;\n    };\n    plot.getXAxes = function () {\n      return xaxes;\n    };\n    plot.getYAxes = function () {\n      return yaxes;\n    };\n    plot.c2p = canvasToAxisCoords;\n    plot.p2c = axisToCanvasCoords;\n    plot.getOptions = function () {\n      return options;\n    };\n    plot.highlight = highlight;\n    plot.unhighlight = unhighlight;\n    plot.triggerRedrawOverlay = triggerRedrawOverlay;\n    plot.pointOffset = function (point) {\n      return {\n        left: parseInt(xaxes[axisNumber(point, \"x\") - 1].p2c(+point.x) + plotOffset.left, 10),\n        top: parseInt(yaxes[axisNumber(point, \"y\") - 1].p2c(+point.y) + plotOffset.top, 10)\n      };\n    };\n    plot.shutdown = shutdown;\n    plot.destroy = function () {\n      shutdown();\n      placeholder.removeData(\"plot\").empty();\n      series = [];\n      options = null;\n      surface = null;\n      overlay = null;\n      eventHolder = null;\n      ctx = null;\n      octx = null;\n      xaxes = [];\n      yaxes = [];\n      hooks = null;\n      highlights = [];\n      plot = null;\n    };\n    plot.resize = function () {\n      var width = placeholder.width(),\n        height = placeholder.height();\n      surface.resize(width, height);\n      overlay.resize(width, height);\n    };\n\n    plot.hooks = hooks;\n\n    initPlugins(plot);\n    parseOptions(options_);\n    setupCanvases();\n    setData(data_);\n    setupGrid();\n    draw();\n    bindEvents();\n    function executeHooks(hook, args) {\n      args = [plot].concat(args);\n      for (var i = 0; i < hook.length; ++i) {\n        hook[i].apply(this, args);\n      }\n    }\n    function initPlugins() {\n\n      var classes = {\n        Canvas: Canvas\n      };\n      for (var i = 0; i < plugins.length; ++i) {\n        var p = plugins[i];\n        p.init(plot, classes);\n        if (p.options) $.extend(true, options, p.options);\n      }\n    }\n    function parseOptions(opts) {\n      $.extend(true, options, opts);\n\n      if (opts && opts.colors) {\n        options.colors = opts.colors;\n      }\n      if (options.xaxis.color == null) options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n      if (options.yaxis.color == null) options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n      if (options.xaxis.tickColor == null)\n        options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;\n      if (options.yaxis.tickColor == null)\n        options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;\n      if (options.grid.borderColor == null) options.grid.borderColor = options.grid.color;\n      if (options.grid.tickColor == null) options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n\n      var i,\n        axisOptions,\n        axisCount,\n        fontSize = placeholder.css(\"font-size\"),\n        fontSizeDefault = fontSize ? +fontSize.replace(\"px\", \"\") : 13,\n        fontDefaults = {\n          style: placeholder.css(\"font-style\"),\n          size: Math.round(0.8 * fontSizeDefault),\n          variant: placeholder.css(\"font-variant\"),\n          weight: placeholder.css(\"font-weight\"),\n          family: placeholder.css(\"font-family\")\n        };\n      axisCount = options.xaxes.length || 1;\n      for (i = 0; i < axisCount; ++i) {\n        axisOptions = options.xaxes[i];\n        if (axisOptions && !axisOptions.tickColor) {\n          axisOptions.tickColor = axisOptions.color;\n        }\n        axisOptions = $.extend(true, {}, options.xaxis, axisOptions);\n        options.xaxes[i] = axisOptions;\n        if (axisOptions.font) {\n          axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n          if (!axisOptions.font.color) {\n            axisOptions.font.color = axisOptions.color;\n          }\n          if (!axisOptions.font.lineHeight) {\n            axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n          }\n        }\n      }\n      axisCount = options.yaxes.length || 1;\n      for (i = 0; i < axisCount; ++i) {\n        axisOptions = options.yaxes[i];\n        if (axisOptions && !axisOptions.tickColor) {\n          axisOptions.tickColor = axisOptions.color;\n        }\n        axisOptions = $.extend(true, {}, options.yaxis, axisOptions);\n        options.yaxes[i] = axisOptions;\n        if (axisOptions.font) {\n          axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n          if (!axisOptions.font.color) {\n            axisOptions.font.color = axisOptions.color;\n          }\n          if (!axisOptions.font.lineHeight) {\n            axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n          }\n        }\n      }\n\n      if (options.xaxis.noTicks && options.xaxis.ticks == null) options.xaxis.ticks = options.xaxis.noTicks;\n      if (options.yaxis.noTicks && options.yaxis.ticks == null) options.yaxis.ticks = options.yaxis.noTicks;\n      if (options.x2axis) {\n        options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);\n        options.xaxes[1].position = \"top\";\n        if (options.x2axis.min == null) {\n          options.xaxes[1].min = null;\n        }\n        if (options.x2axis.max == null) {\n          options.xaxes[1].max = null;\n        }\n      }\n      if (options.y2axis) {\n        options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);\n        options.yaxes[1].position = \"right\";\n        if (options.y2axis.min == null) {\n          options.yaxes[1].min = null;\n        }\n        if (options.y2axis.max == null) {\n          options.yaxes[1].max = null;\n        }\n      }\n      if (options.grid.coloredAreas) options.grid.markings = options.grid.coloredAreas;\n      if (options.grid.coloredAreasColor) options.grid.markingsColor = options.grid.coloredAreasColor;\n      if (options.lines) $.extend(true, options.series.lines, options.lines);\n      if (options.points) $.extend(true, options.series.points, options.points);\n      if (options.bars) $.extend(true, options.series.bars, options.bars);\n      if (options.shadowSize != null) options.series.shadowSize = options.shadowSize;\n      if (options.highlightColor != null) options.series.highlightColor = options.highlightColor;\n\n      for (i = 0; i < options.xaxes.length; ++i) {\n        getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];\n      }\n      for (i = 0; i < options.yaxes.length; ++i) {\n        getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];\n      }\n\n      for (var n in hooks) {\n        if (options.hooks[n] && options.hooks[n].length) hooks[n] = hooks[n].concat(options.hooks[n]);\n      }\n      executeHooks(hooks.processOptions, [options]);\n    }\n    function setData(d) {\n      series = parseData(d);\n      fillInSeriesOptions();\n      processData();\n    }\n    function parseData(d) {\n      var res = [];\n      for (var i = 0; i < d.length; ++i) {\n        var s = $.extend(true, {}, options.series);\n        if (d[i].data != null) {\n          s.data = d[i].data;\n          delete d[i].data;\n          $.extend(true, s, d[i]);\n          d[i].data = s.data;\n        } else s.data = d[i];\n        res.push(s);\n      }\n      return res;\n    }\n    function axisNumber(obj, coord) {\n      var a = obj[coord + \"axis\"];\n      if (typeof a == \"object\")\n        a = a.n;\n      if (typeof a != \"number\") a = 1;\n      return a;\n    }\n    function allAxes() {\n      return $.grep(xaxes.concat(yaxes), function (a) {\n        return a;\n      });\n    }\n    function canvasToAxisCoords(pos) {\n      var res = {},\n        i,\n        axis;\n      for (i = 0; i < xaxes.length; ++i) {\n        axis = xaxes[i];\n        if (axis && axis.used) res[\"x\" + axis.n] = axis.c2p(pos.left);\n      }\n      for (i = 0; i < yaxes.length; ++i) {\n        axis = yaxes[i];\n        if (axis && axis.used) res[\"y\" + axis.n] = axis.c2p(pos.top);\n      }\n      if (res.x1 !== undefined) res.x = res.x1;\n      if (res.y1 !== undefined) res.y = res.y1;\n      return res;\n    }\n    function axisToCanvasCoords(pos) {\n      var res = {},\n        i,\n        axis,\n        key;\n      for (i = 0; i < xaxes.length; ++i) {\n        axis = xaxes[i];\n        if (axis && axis.used) {\n          key = \"x\" + axis.n;\n          if (pos[key] == null && axis.n == 1) key = \"x\";\n          if (pos[key] != null) {\n            res.left = axis.p2c(pos[key]);\n            break;\n          }\n        }\n      }\n      for (i = 0; i < yaxes.length; ++i) {\n        axis = yaxes[i];\n        if (axis && axis.used) {\n          key = \"y\" + axis.n;\n          if (pos[key] == null && axis.n == 1) key = \"y\";\n          if (pos[key] != null) {\n            res.top = axis.p2c(pos[key]);\n            break;\n          }\n        }\n      }\n      return res;\n    }\n    function getOrCreateAxis(axes, number) {\n      if (!axes[number - 1]) axes[number - 1] = {\n        n: number,\n        direction: axes == xaxes ? \"x\" : \"y\",\n        options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)\n      };\n      return axes[number - 1];\n    }\n    function fillInSeriesOptions() {\n      var neededColors = series.length,\n        maxIndex = -1,\n        i;\n\n      for (i = 0; i < series.length; ++i) {\n        var sc = series[i].color;\n        if (sc != null) {\n          neededColors--;\n          if (typeof sc == \"number\" && sc > maxIndex) {\n            maxIndex = sc;\n          }\n        }\n      }\n\n      if (neededColors <= maxIndex) {\n        neededColors = maxIndex + 1;\n      }\n\n      var c,\n        colors = [],\n        colorPool = options.colors,\n        colorPoolSize = colorPool.length,\n        variation = 0;\n      for (i = 0; i < neededColors; i++) {\n        c = $.color.parse(colorPool[i % colorPoolSize] || \"#666\");\n\n        if (i % colorPoolSize == 0 && i) {\n          if (variation >= 0) {\n            if (variation < 0.5) {\n              variation = -variation - 0.2;\n            } else variation = 0;\n          } else variation = -variation;\n        }\n        colors[i] = c.scale('rgb', 1 + variation);\n      }\n\n      var colori = 0,\n        s;\n      for (i = 0; i < series.length; ++i) {\n        s = series[i];\n\n        if (s.color == null) {\n          s.color = colors[colori].toString();\n          ++colori;\n        } else if (typeof s.color == \"number\") s.color = colors[s.color].toString();\n\n        if (s.lines.show == null) {\n          var v,\n            show = true;\n          for (v in s) {\n            if (s[v] && s[v].show) {\n              show = false;\n              break;\n            }\n          }\n          if (show) s.lines.show = true;\n        }\n\n        if (s.lines.zero == null) {\n          s.lines.zero = !!s.lines.fill;\n        }\n\n        s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, \"x\"));\n        s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, \"y\"));\n      }\n    }\n    function processData() {\n      var topSentry = Number.POSITIVE_INFINITY,\n        bottomSentry = Number.NEGATIVE_INFINITY,\n        fakeInfinity = Number.MAX_VALUE,\n        i,\n        j,\n        k,\n        m,\n        length,\n        s,\n        points,\n        ps,\n        x,\n        y,\n        axis,\n        val,\n        f,\n        p,\n        data,\n        format;\n      function updateAxis(axis, min, max) {\n        if (min < axis.datamin && min != -fakeInfinity) axis.datamin = min;\n        if (max > axis.datamax && max != fakeInfinity) axis.datamax = max;\n      }\n      $.each(allAxes(), function (_, axis) {\n        axis.datamin = topSentry;\n        axis.datamax = bottomSentry;\n        axis.used = false;\n      });\n      for (i = 0; i < series.length; ++i) {\n        s = series[i];\n        s.datapoints = {\n          points: []\n        };\n        executeHooks(hooks.processRawData, [s, s.data, s.datapoints]);\n      }\n\n      for (i = 0; i < series.length; ++i) {\n        s = series[i];\n        data = s.data;\n        format = s.datapoints.format;\n        if (!format) {\n          format = [];\n          format.push({\n            x: true,\n            number: true,\n            required: true\n          });\n          format.push({\n            y: true,\n            number: true,\n            required: true\n          });\n          if (s.bars.show || s.lines.show && s.lines.fill) {\n            var autoscale = !!(s.bars.show && s.bars.zero || s.lines.show && s.lines.zero);\n            format.push({\n              y: true,\n              number: true,\n              required: false,\n              defaultValue: 0,\n              autoscale: autoscale\n            });\n            if (s.bars.horizontal) {\n              delete format[format.length - 1].y;\n              format[format.length - 1].x = true;\n            }\n          }\n          s.datapoints.format = format;\n        }\n        if (s.datapoints.pointsize != null) continue;\n\n        s.datapoints.pointsize = format.length;\n        ps = s.datapoints.pointsize;\n        points = s.datapoints.points;\n        var insertSteps = s.lines.show && s.lines.steps;\n        s.xaxis.used = s.yaxis.used = true;\n        for (j = k = 0; j < data.length; ++j, k += ps) {\n          p = data[j];\n          var nullify = p == null;\n          if (!nullify) {\n            for (m = 0; m < ps; ++m) {\n              val = p[m];\n              f = format[m];\n              if (f) {\n                if (f.number && val != null) {\n                  val = +val;\n                  if (isNaN(val)) val = null;else if (val == Infinity) val = fakeInfinity;else if (val == -Infinity) val = -fakeInfinity;\n                }\n                if (val == null) {\n                  if (f.required) nullify = true;\n                  if (f.defaultValue != null) val = f.defaultValue;\n                }\n              }\n              points[k + m] = val;\n            }\n          }\n          if (nullify) {\n            for (m = 0; m < ps; ++m) {\n              val = points[k + m];\n              if (val != null) {\n                f = format[m];\n                if (f.autoscale !== false) {\n                  if (f.x) {\n                    updateAxis(s.xaxis, val, val);\n                  }\n                  if (f.y) {\n                    updateAxis(s.yaxis, val, val);\n                  }\n                }\n              }\n              points[k + m] = null;\n            }\n          } else {\n            if (insertSteps && k > 0 && points[k - ps] != null && points[k - ps] != points[k] && points[k - ps + 1] != points[k + 1]) {\n              for (m = 0; m < ps; ++m) {\n                points[k + ps + m] = points[k + m];\n              }\n\n              points[k + 1] = points[k - ps + 1];\n\n              k += ps;\n            }\n          }\n        }\n      }\n\n      for (i = 0; i < series.length; ++i) {\n        s = series[i];\n        executeHooks(hooks.processDatapoints, [s, s.datapoints]);\n      }\n\n      for (i = 0; i < series.length; ++i) {\n        s = series[i];\n        points = s.datapoints.points;\n        ps = s.datapoints.pointsize;\n        format = s.datapoints.format;\n        var xmin = topSentry,\n          ymin = topSentry,\n          xmax = bottomSentry,\n          ymax = bottomSentry;\n        for (j = 0; j < points.length; j += ps) {\n          if (points[j] == null) continue;\n          for (m = 0; m < ps; ++m) {\n            val = points[j + m];\n            f = format[m];\n            if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity) continue;\n            if (f.x) {\n              if (val < xmin) xmin = val;\n              if (val > xmax) xmax = val;\n            }\n            if (f.y) {\n              if (val < ymin) ymin = val;\n              if (val > ymax) ymax = val;\n            }\n          }\n        }\n        if (s.bars.show) {\n          var delta;\n          switch (s.bars.align) {\n            case \"left\":\n              delta = 0;\n              break;\n            case \"right\":\n              delta = -s.bars.barWidth;\n              break;\n            default:\n              delta = -s.bars.barWidth / 2;\n          }\n          if (s.bars.horizontal) {\n            ymin += delta;\n            ymax += delta + s.bars.barWidth;\n          } else {\n            xmin += delta;\n            xmax += delta + s.bars.barWidth;\n          }\n        }\n        updateAxis(s.xaxis, xmin, xmax);\n        updateAxis(s.yaxis, ymin, ymax);\n      }\n      $.each(allAxes(), function (_, axis) {\n        if (axis.datamin == topSentry) axis.datamin = null;\n        if (axis.datamax == bottomSentry) axis.datamax = null;\n      });\n    }\n    function setupCanvases() {\n\n      placeholder.css(\"padding\", 0).children().filter(function () {\n        return !$(this).hasClass(\"flot-overlay\") && !$(this).hasClass('flot-base');\n      }).remove();\n      if (placeholder.css(\"position\") == 'static') placeholder.css(\"position\", \"relative\");\n\n      surface = new Canvas(\"flot-base\", placeholder);\n      overlay = new Canvas(\"flot-overlay\", placeholder);\n\n      ctx = surface.context;\n      octx = overlay.context;\n\n      eventHolder = $(overlay.element).unbind();\n\n      var existing = placeholder.data(\"plot\");\n      if (existing) {\n        existing.shutdown();\n        overlay.clear();\n      }\n\n      placeholder.data(\"plot\", plot);\n    }\n    function bindEvents() {\n      if (options.grid.hoverable) {\n        eventHolder.mousemove(onMouseMove);\n\n        eventHolder.bind(\"mouseleave\", onMouseLeave);\n      }\n      if (options.grid.clickable) eventHolder.click(onClick);\n      executeHooks(hooks.bindEvents, [eventHolder]);\n    }\n    function shutdown() {\n      if (redrawTimeout) clearTimeout(redrawTimeout);\n      eventHolder.unbind(\"mousemove\", onMouseMove);\n      eventHolder.unbind(\"mouseleave\", onMouseLeave);\n      eventHolder.unbind(\"click\", onClick);\n      executeHooks(hooks.shutdown, [eventHolder]);\n    }\n    function setTransformationHelpers(axis) {\n\n      function identity(x) {\n        return x;\n      }\n      var s,\n        m,\n        t = axis.options.transform || identity,\n        it = axis.options.inverseTransform;\n\n      if (axis.direction == \"x\") {\n        s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));\n        m = Math.min(t(axis.max), t(axis.min));\n      } else {\n        s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));\n        s = -s;\n        m = Math.max(t(axis.max), t(axis.min));\n      }\n\n      if (t == identity)\n        axis.p2c = function (p) {\n          return (p - m) * s;\n        };else axis.p2c = function (p) {\n        return (t(p) - m) * s;\n      };\n      if (!it) axis.c2p = function (c) {\n        return m + c / s;\n      };else axis.c2p = function (c) {\n        return it(m + c / s);\n      };\n    }\n    function measureTickLabels(axis) {\n      var opts = axis.options,\n        ticks = axis.ticks || [],\n        labelWidth = opts.labelWidth || 0,\n        labelHeight = opts.labelHeight || 0,\n        maxWidth = labelWidth || (axis.direction == \"x\" ? Math.floor(surface.width / (ticks.length || 1)) : null),\n        legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n        layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n        font = opts.font || \"flot-tick-label tickLabel\";\n      for (var i = 0; i < ticks.length; ++i) {\n        var t = ticks[i];\n        if (!t.label) continue;\n        var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);\n        labelWidth = Math.max(labelWidth, info.width);\n        labelHeight = Math.max(labelHeight, info.height);\n      }\n      axis.labelWidth = opts.labelWidth || labelWidth;\n      axis.labelHeight = opts.labelHeight || labelHeight;\n    }\n    function allocateAxisBoxFirstPhase(axis) {\n\n      var lw = axis.labelWidth,\n        lh = axis.labelHeight,\n        pos = axis.options.position,\n        isXAxis = axis.direction === \"x\",\n        tickLength = axis.options.tickLength,\n        axisMargin = options.grid.axisMargin,\n        padding = options.grid.labelMargin,\n        innermost = true,\n        outermost = true,\n        first = true,\n        found = false;\n\n      $.each(isXAxis ? xaxes : yaxes, function (i, a) {\n        if (a && (a.show || a.reserveSpace)) {\n          if (a === axis) {\n            found = true;\n          } else if (a.options.position === pos) {\n            if (found) {\n              outermost = false;\n            } else {\n              innermost = false;\n            }\n          }\n          if (!found) {\n            first = false;\n          }\n        }\n      });\n\n      if (outermost) {\n        axisMargin = 0;\n      }\n\n      if (tickLength == null) {\n        tickLength = first ? \"full\" : 5;\n      }\n      if (!isNaN(+tickLength)) padding += +tickLength;\n      if (isXAxis) {\n        lh += padding;\n        if (pos == \"bottom\") {\n          plotOffset.bottom += lh + axisMargin;\n          axis.box = {\n            top: surface.height - plotOffset.bottom,\n            height: lh\n          };\n        } else {\n          axis.box = {\n            top: plotOffset.top + axisMargin,\n            height: lh\n          };\n          plotOffset.top += lh + axisMargin;\n        }\n      } else {\n        lw += padding;\n        if (pos == \"left\") {\n          axis.box = {\n            left: plotOffset.left + axisMargin,\n            width: lw\n          };\n          plotOffset.left += lw + axisMargin;\n        } else {\n          plotOffset.right += lw + axisMargin;\n          axis.box = {\n            left: surface.width - plotOffset.right,\n            width: lw\n          };\n        }\n      }\n\n      axis.position = pos;\n      axis.tickLength = tickLength;\n      axis.box.padding = padding;\n      axis.innermost = innermost;\n    }\n    function allocateAxisBoxSecondPhase(axis) {\n      if (axis.direction == \"x\") {\n        axis.box.left = plotOffset.left - axis.labelWidth / 2;\n        axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;\n      } else {\n        axis.box.top = plotOffset.top - axis.labelHeight / 2;\n        axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;\n      }\n    }\n    function adjustLayoutForThingsStickingOut() {\n\n      var minMargin = options.grid.minBorderMargin,\n        axis,\n        i;\n\n      if (minMargin == null) {\n        minMargin = 0;\n        for (i = 0; i < series.length; ++i) {\n          minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth / 2));\n        }\n      }\n      var margins = {\n        left: minMargin,\n        right: minMargin,\n        top: minMargin,\n        bottom: minMargin\n      };\n\n      $.each(allAxes(), function (_, axis) {\n        if (axis.reserveSpace && axis.ticks && axis.ticks.length) {\n          if (axis.direction === \"x\") {\n            margins.left = Math.max(margins.left, axis.labelWidth / 2);\n            margins.right = Math.max(margins.right, axis.labelWidth / 2);\n          } else {\n            margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);\n            margins.top = Math.max(margins.top, axis.labelHeight / 2);\n          }\n        }\n      });\n      plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));\n      plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));\n      plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));\n      plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));\n    }\n    function setupGrid() {\n      var i,\n        axes = allAxes(),\n        showGrid = options.grid.show;\n\n      for (var a in plotOffset) {\n        var margin = options.grid.margin || 0;\n        plotOffset[a] = typeof margin == \"number\" ? margin : margin[a] || 0;\n      }\n      executeHooks(hooks.processOffset, [plotOffset]);\n\n      for (var a in plotOffset) {\n        if (typeof options.grid.borderWidth == \"object\") {\n          plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;\n        } else {\n          plotOffset[a] += showGrid ? options.grid.borderWidth : 0;\n        }\n      }\n      $.each(axes, function (_, axis) {\n        var axisOpts = axis.options;\n        axis.show = axisOpts.show == null ? axis.used : axisOpts.show;\n        axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;\n        setRange(axis);\n      });\n      if (showGrid) {\n        var allocatedAxes = $.grep(axes, function (axis) {\n          return axis.show || axis.reserveSpace;\n        });\n        $.each(allocatedAxes, function (_, axis) {\n          setupTickGeneration(axis);\n          setTicks(axis);\n          snapRangeToTicks(axis, axis.ticks);\n          measureTickLabels(axis);\n        });\n\n        for (i = allocatedAxes.length - 1; i >= 0; --i) {\n          allocateAxisBoxFirstPhase(allocatedAxes[i]);\n        }\n\n        adjustLayoutForThingsStickingOut();\n        $.each(allocatedAxes, function (_, axis) {\n          allocateAxisBoxSecondPhase(axis);\n        });\n      }\n      plotWidth = surface.width - plotOffset.left - plotOffset.right;\n      plotHeight = surface.height - plotOffset.bottom - plotOffset.top;\n\n      $.each(axes, function (_, axis) {\n        setTransformationHelpers(axis);\n      });\n      if (showGrid) {\n        drawAxisLabels();\n      }\n      insertLegend();\n    }\n    function setRange(axis) {\n      var opts = axis.options,\n        min = +(opts.min != null ? opts.min : axis.datamin),\n        max = +(opts.max != null ? opts.max : axis.datamax),\n        delta = max - min;\n      if (delta == 0.0) {\n        var widen = max == 0 ? 1 : 0.01;\n        if (opts.min == null) min -= widen;\n        if (opts.max == null || opts.min != null) max += widen;\n      } else {\n        var margin = opts.autoscaleMargin;\n        if (margin != null) {\n          if (opts.min == null) {\n            min -= delta * margin;\n            if (min < 0 && axis.datamin != null && axis.datamin >= 0) min = 0;\n          }\n          if (opts.max == null) {\n            max += delta * margin;\n            if (max > 0 && axis.datamax != null && axis.datamax <= 0) max = 0;\n          }\n        }\n      }\n      axis.min = min;\n      axis.max = max;\n    }\n    function setupTickGeneration(axis) {\n      var opts = axis.options;\n\n      var noTicks;\n      if (typeof opts.ticks == \"number\" && opts.ticks > 0) noTicks = opts.ticks;else\n        noTicks = 0.3 * Math.sqrt(axis.direction == \"x\" ? surface.width : surface.height);\n      var delta = (axis.max - axis.min) / noTicks,\n        dec = -Math.floor(Math.log(delta) / Math.LN10),\n        maxDec = opts.tickDecimals;\n      if (maxDec != null && dec > maxDec) {\n        dec = maxDec;\n      }\n      var magn = Math.pow(10, -dec),\n        norm = delta / magn,\n        size;\n      if (norm < 1.5) {\n        size = 1;\n      } else if (norm < 3) {\n        size = 2;\n        if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {\n          size = 2.5;\n          ++dec;\n        }\n      } else if (norm < 7.5) {\n        size = 5;\n      } else {\n        size = 10;\n      }\n      size *= magn;\n      if (opts.minTickSize != null && size < opts.minTickSize) {\n        size = opts.minTickSize;\n      }\n      axis.delta = delta;\n      axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);\n      axis.tickSize = opts.tickSize || size;\n\n      if (opts.mode == \"time\" && !axis.tickGenerator) {\n        throw new Error(\"Time mode requires the flot.time plugin.\");\n      }\n\n      if (!axis.tickGenerator) {\n        axis.tickGenerator = function (axis) {\n          var ticks = [],\n            start = floorInBase(axis.min, axis.tickSize),\n            i = 0,\n            v = Number.NaN,\n            prev;\n          do {\n            prev = v;\n            v = start + i * axis.tickSize;\n            ticks.push(v);\n            ++i;\n          } while (v < axis.max && v != prev);\n          return ticks;\n        };\n        axis.tickFormatter = function (value, axis) {\n          var factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;\n          var formatted = \"\" + Math.round(value * factor) / factor;\n\n          if (axis.tickDecimals != null) {\n            var decimal = formatted.indexOf(\".\");\n            var precision = decimal == -1 ? 0 : formatted.length - decimal - 1;\n            if (precision < axis.tickDecimals) {\n              return (precision ? formatted : formatted + \".\") + (\"\" + factor).substr(1, axis.tickDecimals - precision);\n            }\n          }\n          return formatted;\n        };\n      }\n      if ($.isFunction(opts.tickFormatter)) axis.tickFormatter = function (v, axis) {\n        return \"\" + opts.tickFormatter(v, axis);\n      };\n      if (opts.alignTicksWithAxis != null) {\n        var otherAxis = (axis.direction == \"x\" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];\n        if (otherAxis && otherAxis.used && otherAxis != axis) {\n          var niceTicks = axis.tickGenerator(axis);\n          if (niceTicks.length > 0) {\n            if (opts.min == null) axis.min = Math.min(axis.min, niceTicks[0]);\n            if (opts.max == null && niceTicks.length > 1) axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);\n          }\n          axis.tickGenerator = function (axis) {\n            var ticks = [],\n              v,\n              i;\n            for (i = 0; i < otherAxis.ticks.length; ++i) {\n              v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);\n              v = axis.min + v * (axis.max - axis.min);\n              ticks.push(v);\n            }\n            return ticks;\n          };\n\n          if (!axis.mode && opts.tickDecimals == null) {\n            var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),\n              ts = axis.tickGenerator(axis);\n\n            if (!(ts.length > 1 && /\\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec)))) axis.tickDecimals = extraDec;\n          }\n        }\n      }\n    }\n    function setTicks(axis) {\n      var oticks = axis.options.ticks,\n        ticks = [];\n      if (oticks == null || typeof oticks == \"number\" && oticks > 0) ticks = axis.tickGenerator(axis);else if (oticks) {\n        if ($.isFunction(oticks))\n          ticks = oticks(axis);else ticks = oticks;\n      }\n\n      var i, v;\n      axis.ticks = [];\n      for (i = 0; i < ticks.length; ++i) {\n        var label = null;\n        var t = ticks[i];\n        if (typeof t == \"object\") {\n          v = +t[0];\n          if (t.length > 1) label = t[1];\n        } else v = +t;\n        if (label == null) label = axis.tickFormatter(v, axis);\n        if (!isNaN(v)) axis.ticks.push({\n          v: v,\n          label: label\n        });\n      }\n    }\n    function snapRangeToTicks(axis, ticks) {\n      if (axis.options.autoscaleMargin && ticks.length > 0) {\n        if (axis.options.min == null) axis.min = Math.min(axis.min, ticks[0].v);\n        if (axis.options.max == null && ticks.length > 1) axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);\n      }\n    }\n    function draw() {\n      surface.clear();\n      executeHooks(hooks.drawBackground, [ctx]);\n      var grid = options.grid;\n\n      if (grid.show && grid.backgroundColor) drawBackground();\n      if (grid.show && !grid.aboveData) {\n        drawGrid();\n      }\n      for (var i = 0; i < series.length; ++i) {\n        executeHooks(hooks.drawSeries, [ctx, series[i]]);\n        drawSeries(series[i]);\n      }\n      executeHooks(hooks.draw, [ctx]);\n      if (grid.show && grid.aboveData) {\n        drawGrid();\n      }\n      surface.render();\n\n      triggerRedrawOverlay();\n    }\n    function extractRange(ranges, coord) {\n      var axis,\n        from,\n        to,\n        key,\n        axes = allAxes();\n      for (var i = 0; i < axes.length; ++i) {\n        axis = axes[i];\n        if (axis.direction == coord) {\n          key = coord + axis.n + \"axis\";\n          if (!ranges[key] && axis.n == 1) key = coord + \"axis\";\n          if (ranges[key]) {\n            from = ranges[key].from;\n            to = ranges[key].to;\n            break;\n          }\n        }\n      }\n\n      if (!ranges[key]) {\n        axis = coord == \"x\" ? xaxes[0] : yaxes[0];\n        from = ranges[coord + \"1\"];\n        to = ranges[coord + \"2\"];\n      }\n\n      if (from != null && to != null && from > to) {\n        var tmp = from;\n        from = to;\n        to = tmp;\n      }\n      return {\n        from: from,\n        to: to,\n        axis: axis\n      };\n    }\n    function drawBackground() {\n      ctx.save();\n      ctx.translate(plotOffset.left, plotOffset.top);\n      ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, \"rgba(255, 255, 255, 0)\");\n      ctx.fillRect(0, 0, plotWidth, plotHeight);\n      ctx.restore();\n    }\n    function drawGrid() {\n      var i, axes, bw, bc;\n      ctx.save();\n      ctx.translate(plotOffset.left, plotOffset.top);\n\n      var markings = options.grid.markings;\n      if (markings) {\n        if ($.isFunction(markings)) {\n          axes = plot.getAxes();\n          axes.xmin = axes.xaxis.min;\n          axes.xmax = axes.xaxis.max;\n          axes.ymin = axes.yaxis.min;\n          axes.ymax = axes.yaxis.max;\n          markings = markings(axes);\n        }\n        for (i = 0; i < markings.length; ++i) {\n          var m = markings[i],\n            xrange = extractRange(m, \"x\"),\n            yrange = extractRange(m, \"y\");\n\n          if (xrange.from == null) xrange.from = xrange.axis.min;\n          if (xrange.to == null) xrange.to = xrange.axis.max;\n          if (yrange.from == null) yrange.from = yrange.axis.min;\n          if (yrange.to == null) yrange.to = yrange.axis.max;\n\n          if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max || yrange.to < yrange.axis.min || yrange.from > yrange.axis.max) continue;\n          xrange.from = Math.max(xrange.from, xrange.axis.min);\n          xrange.to = Math.min(xrange.to, xrange.axis.max);\n          yrange.from = Math.max(yrange.from, yrange.axis.min);\n          yrange.to = Math.min(yrange.to, yrange.axis.max);\n          var xequal = xrange.from === xrange.to,\n            yequal = yrange.from === yrange.to;\n          if (xequal && yequal) {\n            continue;\n          }\n\n          xrange.from = Math.floor(xrange.axis.p2c(xrange.from));\n          xrange.to = Math.floor(xrange.axis.p2c(xrange.to));\n          yrange.from = Math.floor(yrange.axis.p2c(yrange.from));\n          yrange.to = Math.floor(yrange.axis.p2c(yrange.to));\n          if (xequal || yequal) {\n            var lineWidth = m.lineWidth || options.grid.markingsLineWidth,\n              subPixel = lineWidth % 2 ? 0.5 : 0;\n            ctx.beginPath();\n            ctx.strokeStyle = m.color || options.grid.markingsColor;\n            ctx.lineWidth = lineWidth;\n            if (xequal) {\n              ctx.moveTo(xrange.to + subPixel, yrange.from);\n              ctx.lineTo(xrange.to + subPixel, yrange.to);\n            } else {\n              ctx.moveTo(xrange.from, yrange.to + subPixel);\n              ctx.lineTo(xrange.to, yrange.to + subPixel);\n            }\n            ctx.stroke();\n          } else {\n            ctx.fillStyle = m.color || options.grid.markingsColor;\n            ctx.fillRect(xrange.from, yrange.to, xrange.to - xrange.from, yrange.from - yrange.to);\n          }\n        }\n      }\n\n      axes = allAxes();\n      bw = options.grid.borderWidth;\n      for (var j = 0; j < axes.length; ++j) {\n        var axis = axes[j],\n          box = axis.box,\n          t = axis.tickLength,\n          x,\n          y,\n          xoff,\n          yoff;\n        if (!axis.show || axis.ticks.length == 0) continue;\n        ctx.lineWidth = 1;\n\n        if (axis.direction == \"x\") {\n          x = 0;\n          if (t == \"full\") y = axis.position == \"top\" ? 0 : plotHeight;else y = box.top - plotOffset.top + (axis.position == \"top\" ? box.height : 0);\n        } else {\n          y = 0;\n          if (t == \"full\") x = axis.position == \"left\" ? 0 : plotWidth;else x = box.left - plotOffset.left + (axis.position == \"left\" ? box.width : 0);\n        }\n\n        if (!axis.innermost) {\n          ctx.strokeStyle = axis.options.color;\n          ctx.beginPath();\n          xoff = yoff = 0;\n          if (axis.direction == \"x\") xoff = plotWidth + 1;else yoff = plotHeight + 1;\n          if (ctx.lineWidth == 1) {\n            if (axis.direction == \"x\") {\n              y = Math.floor(y) + 0.5;\n            } else {\n              x = Math.floor(x) + 0.5;\n            }\n          }\n          ctx.moveTo(x, y);\n          ctx.lineTo(x + xoff, y + yoff);\n          ctx.stroke();\n        }\n\n        ctx.strokeStyle = axis.options.tickColor;\n        ctx.beginPath();\n        for (i = 0; i < axis.ticks.length; ++i) {\n          var v = axis.ticks[i].v;\n          xoff = yoff = 0;\n          if (isNaN(v) || v < axis.min || v > axis.max\n          || t == \"full\" && (typeof bw == \"object\" && bw[axis.position] > 0 || bw > 0) && (v == axis.min || v == axis.max)) continue;\n          if (axis.direction == \"x\") {\n            x = axis.p2c(v);\n            yoff = t == \"full\" ? -plotHeight : t;\n            if (axis.position == \"top\") yoff = -yoff;\n          } else {\n            y = axis.p2c(v);\n            xoff = t == \"full\" ? -plotWidth : t;\n            if (axis.position == \"left\") xoff = -xoff;\n          }\n          if (ctx.lineWidth == 1) {\n            if (axis.direction == \"x\") x = Math.floor(x) + 0.5;else y = Math.floor(y) + 0.5;\n          }\n          ctx.moveTo(x, y);\n          ctx.lineTo(x + xoff, y + yoff);\n        }\n        ctx.stroke();\n      }\n\n      if (bw) {\n        bc = options.grid.borderColor;\n        if (typeof bw == \"object\" || typeof bc == \"object\") {\n          if (typeof bw !== \"object\") {\n            bw = {\n              top: bw,\n              right: bw,\n              bottom: bw,\n              left: bw\n            };\n          }\n          if (typeof bc !== \"object\") {\n            bc = {\n              top: bc,\n              right: bc,\n              bottom: bc,\n              left: bc\n            };\n          }\n          if (bw.top > 0) {\n            ctx.strokeStyle = bc.top;\n            ctx.lineWidth = bw.top;\n            ctx.beginPath();\n            ctx.moveTo(0 - bw.left, 0 - bw.top / 2);\n            ctx.lineTo(plotWidth, 0 - bw.top / 2);\n            ctx.stroke();\n          }\n          if (bw.right > 0) {\n            ctx.strokeStyle = bc.right;\n            ctx.lineWidth = bw.right;\n            ctx.beginPath();\n            ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);\n            ctx.lineTo(plotWidth + bw.right / 2, plotHeight);\n            ctx.stroke();\n          }\n          if (bw.bottom > 0) {\n            ctx.strokeStyle = bc.bottom;\n            ctx.lineWidth = bw.bottom;\n            ctx.beginPath();\n            ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);\n            ctx.lineTo(0, plotHeight + bw.bottom / 2);\n            ctx.stroke();\n          }\n          if (bw.left > 0) {\n            ctx.strokeStyle = bc.left;\n            ctx.lineWidth = bw.left;\n            ctx.beginPath();\n            ctx.moveTo(0 - bw.left / 2, plotHeight + bw.bottom);\n            ctx.lineTo(0 - bw.left / 2, 0);\n            ctx.stroke();\n          }\n        } else {\n          ctx.lineWidth = bw;\n          ctx.strokeStyle = options.grid.borderColor;\n          ctx.strokeRect(-bw / 2, -bw / 2, plotWidth + bw, plotHeight + bw);\n        }\n      }\n      ctx.restore();\n    }\n    function drawAxisLabels() {\n      $.each(allAxes(), function (_, axis) {\n        var box = axis.box,\n          legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n          layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n          font = axis.options.font || \"flot-tick-label tickLabel\",\n          tick,\n          x,\n          y,\n          halign,\n          valign;\n\n        surface.removeText(layer);\n        if (!axis.show || axis.ticks.length == 0) return;\n        for (var i = 0; i < axis.ticks.length; ++i) {\n          tick = axis.ticks[i];\n          if (!tick.label || tick.v < axis.min || tick.v > axis.max) continue;\n          if (axis.direction == \"x\") {\n            halign = \"center\";\n            x = plotOffset.left + axis.p2c(tick.v);\n            if (axis.position == \"bottom\") {\n              y = box.top + box.padding;\n            } else {\n              y = box.top + box.height - box.padding;\n              valign = \"bottom\";\n            }\n          } else {\n            valign = \"middle\";\n            y = plotOffset.top + axis.p2c(tick.v);\n            if (axis.position == \"left\") {\n              x = box.left + box.width - box.padding;\n              halign = \"right\";\n            } else {\n              x = box.left + box.padding;\n            }\n          }\n          surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);\n        }\n      });\n    }\n    function drawSeries(series) {\n      if (series.lines.show) drawSeriesLines(series);\n      if (series.bars.show) drawSeriesBars(series);\n      if (series.points.show) drawSeriesPoints(series);\n    }\n    function drawSeriesLines(series) {\n      function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {\n        var points = datapoints.points,\n          ps = datapoints.pointsize,\n          prevx = null,\n          prevy = null;\n        ctx.beginPath();\n        for (var i = ps; i < points.length; i += ps) {\n          var x1 = points[i - ps],\n            y1 = points[i - ps + 1],\n            x2 = points[i],\n            y2 = points[i + 1];\n          if (x1 == null || x2 == null) continue;\n\n          if (y1 <= y2 && y1 < axisy.min) {\n            if (y2 < axisy.min) continue;\n            x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n            y1 = axisy.min;\n          } else if (y2 <= y1 && y2 < axisy.min) {\n            if (y1 < axisy.min) continue;\n            x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n            y2 = axisy.min;\n          }\n\n          if (y1 >= y2 && y1 > axisy.max) {\n            if (y2 > axisy.max) continue;\n            x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n            y1 = axisy.max;\n          } else if (y2 >= y1 && y2 > axisy.max) {\n            if (y1 > axisy.max) continue;\n            x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n            y2 = axisy.max;\n          }\n\n          if (x1 <= x2 && x1 < axisx.min) {\n            if (x2 < axisx.min) continue;\n            y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n            x1 = axisx.min;\n          } else if (x2 <= x1 && x2 < axisx.min) {\n            if (x1 < axisx.min) continue;\n            y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n            x2 = axisx.min;\n          }\n\n          if (x1 >= x2 && x1 > axisx.max) {\n            if (x2 > axisx.max) continue;\n            y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n            x1 = axisx.max;\n          } else if (x2 >= x1 && x2 > axisx.max) {\n            if (x1 > axisx.max) continue;\n            y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n            x2 = axisx.max;\n          }\n          if (x1 != prevx || y1 != prevy) ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);\n          prevx = x2;\n          prevy = y2;\n          ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);\n        }\n        ctx.stroke();\n      }\n      function plotLineArea(datapoints, axisx, axisy) {\n        var points = datapoints.points,\n          ps = datapoints.pointsize,\n          bottom = Math.min(Math.max(0, axisy.min), axisy.max),\n          i = 0,\n          top,\n          areaOpen = false,\n          ypos = 1,\n          segmentStart = 0,\n          segmentEnd = 0;\n\n        while (true) {\n          if (ps > 0 && i > points.length + ps) break;\n          i += ps;\n\n          var x1 = points[i - ps],\n            y1 = points[i - ps + ypos],\n            x2 = points[i],\n            y2 = points[i + ypos];\n          if (areaOpen) {\n            if (ps > 0 && x1 != null && x2 == null) {\n              segmentEnd = i;\n              ps = -ps;\n              ypos = 2;\n              continue;\n            }\n            if (ps < 0 && i == segmentStart + ps) {\n              ctx.fill();\n              areaOpen = false;\n              ps = -ps;\n              ypos = 1;\n              i = segmentStart = segmentEnd + ps;\n              continue;\n            }\n          }\n          if (x1 == null || x2 == null) continue;\n\n          if (x1 <= x2 && x1 < axisx.min) {\n            if (x2 < axisx.min) continue;\n            y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n            x1 = axisx.min;\n          } else if (x2 <= x1 && x2 < axisx.min) {\n            if (x1 < axisx.min) continue;\n            y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n            x2 = axisx.min;\n          }\n\n          if (x1 >= x2 && x1 > axisx.max) {\n            if (x2 > axisx.max) continue;\n            y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n            x1 = axisx.max;\n          } else if (x2 >= x1 && x2 > axisx.max) {\n            if (x1 > axisx.max) continue;\n            y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n            x2 = axisx.max;\n          }\n          if (!areaOpen) {\n            ctx.beginPath();\n            ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));\n            areaOpen = true;\n          }\n\n          if (y1 >= axisy.max && y2 >= axisy.max) {\n            ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));\n            ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));\n            continue;\n          } else if (y1 <= axisy.min && y2 <= axisy.min) {\n            ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));\n            ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));\n            continue;\n          }\n\n          var x1old = x1,\n            x2old = x2;\n\n          if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {\n            x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n            y1 = axisy.min;\n          } else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {\n            x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n            y2 = axisy.min;\n          }\n\n          if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {\n            x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n            y1 = axisy.max;\n          } else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {\n            x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n            y2 = axisy.max;\n          }\n\n          if (x1 != x1old) {\n            ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));\n          }\n\n          ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));\n          ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n\n          if (x2 != x2old) {\n            ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n            ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));\n          }\n        }\n      }\n      ctx.save();\n      ctx.translate(plotOffset.left, plotOffset.top);\n      ctx.lineJoin = \"round\";\n      var lw = series.lines.lineWidth,\n        sw = series.shadowSize;\n      if (lw > 0 && sw > 0) {\n        ctx.lineWidth = sw;\n        ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n        var angle = Math.PI / 18;\n        plotLine(series.datapoints, Math.sin(angle) * (lw / 2 + sw / 2), Math.cos(angle) * (lw / 2 + sw / 2), series.xaxis, series.yaxis);\n        ctx.lineWidth = sw / 2;\n        plotLine(series.datapoints, Math.sin(angle) * (lw / 2 + sw / 4), Math.cos(angle) * (lw / 2 + sw / 4), series.xaxis, series.yaxis);\n      }\n      ctx.lineWidth = lw;\n      ctx.strokeStyle = series.color;\n      var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);\n      if (fillStyle) {\n        ctx.fillStyle = fillStyle;\n        plotLineArea(series.datapoints, series.xaxis, series.yaxis);\n      }\n      if (lw > 0) plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);\n      ctx.restore();\n    }\n    function drawSeriesPoints(series) {\n      function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {\n        var points = datapoints.points,\n          ps = datapoints.pointsize;\n        for (var i = 0; i < points.length; i += ps) {\n          var x = points[i],\n            y = points[i + 1];\n          if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max) continue;\n          ctx.beginPath();\n          x = axisx.p2c(x);\n          y = axisy.p2c(y) + offset;\n          if (symbol == \"circle\") ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);else symbol(ctx, x, y, radius, shadow);\n          ctx.closePath();\n          if (fillStyle) {\n            ctx.fillStyle = fillStyle;\n            ctx.fill();\n          }\n          ctx.stroke();\n        }\n      }\n      ctx.save();\n      ctx.translate(plotOffset.left, plotOffset.top);\n      var lw = series.points.lineWidth,\n        sw = series.shadowSize,\n        radius = series.points.radius,\n        symbol = series.points.symbol;\n\n      if (lw == 0) lw = 0.0001;\n      if (lw > 0 && sw > 0) {\n        var w = sw / 2;\n        ctx.lineWidth = w;\n        ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n        plotPoints(series.datapoints, radius, null, w + w / 2, true, series.xaxis, series.yaxis, symbol);\n        ctx.strokeStyle = \"rgba(0,0,0,0.2)\";\n        plotPoints(series.datapoints, radius, null, w / 2, true, series.xaxis, series.yaxis, symbol);\n      }\n      ctx.lineWidth = lw;\n      ctx.strokeStyle = series.color;\n      plotPoints(series.datapoints, radius, getFillStyle(series.points, series.color), 0, false, series.xaxis, series.yaxis, symbol);\n      ctx.restore();\n    }\n    function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {\n      var left, right, bottom, top, drawLeft, drawRight, drawTop, drawBottom, tmp;\n\n      if (horizontal) {\n        drawBottom = drawRight = drawTop = true;\n        drawLeft = false;\n        left = b;\n        right = x;\n        top = y + barLeft;\n        bottom = y + barRight;\n\n        if (right < left) {\n          tmp = right;\n          right = left;\n          left = tmp;\n          drawLeft = true;\n          drawRight = false;\n        }\n      } else {\n        drawLeft = drawRight = drawTop = true;\n        drawBottom = false;\n        left = x + barLeft;\n        right = x + barRight;\n        bottom = b;\n        top = y;\n\n        if (top < bottom) {\n          tmp = top;\n          top = bottom;\n          bottom = tmp;\n          drawBottom = true;\n          drawTop = false;\n        }\n      }\n\n      if (right < axisx.min || left > axisx.max || top < axisy.min || bottom > axisy.max) return;\n      if (left < axisx.min) {\n        left = axisx.min;\n        drawLeft = false;\n      }\n      if (right > axisx.max) {\n        right = axisx.max;\n        drawRight = false;\n      }\n      if (bottom < axisy.min) {\n        bottom = axisy.min;\n        drawBottom = false;\n      }\n      if (top > axisy.max) {\n        top = axisy.max;\n        drawTop = false;\n      }\n      left = axisx.p2c(left);\n      bottom = axisy.p2c(bottom);\n      right = axisx.p2c(right);\n      top = axisy.p2c(top);\n\n      if (fillStyleCallback) {\n        c.fillStyle = fillStyleCallback(bottom, top);\n        c.fillRect(left, top, right - left, bottom - top);\n      }\n\n      if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {\n        c.beginPath();\n\n        c.moveTo(left, bottom);\n        if (drawLeft) c.lineTo(left, top);else c.moveTo(left, top);\n        if (drawTop) c.lineTo(right, top);else c.moveTo(right, top);\n        if (drawRight) c.lineTo(right, bottom);else c.moveTo(right, bottom);\n        if (drawBottom) c.lineTo(left, bottom);else c.moveTo(left, bottom);\n        c.stroke();\n      }\n    }\n    function drawSeriesBars(series) {\n      function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {\n        var points = datapoints.points,\n          ps = datapoints.pointsize;\n        for (var i = 0; i < points.length; i += ps) {\n          if (points[i] == null) continue;\n          drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);\n        }\n      }\n      ctx.save();\n      ctx.translate(plotOffset.left, plotOffset.top);\n\n      ctx.lineWidth = series.bars.lineWidth;\n      ctx.strokeStyle = series.color;\n      var barLeft;\n      switch (series.bars.align) {\n        case \"left\":\n          barLeft = 0;\n          break;\n        case \"right\":\n          barLeft = -series.bars.barWidth;\n          break;\n        default:\n          barLeft = -series.bars.barWidth / 2;\n      }\n      var fillStyleCallback = series.bars.fill ? function (bottom, top) {\n        return getFillStyle(series.bars, series.color, bottom, top);\n      } : null;\n      plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);\n      ctx.restore();\n    }\n    function getFillStyle(filloptions, seriesColor, bottom, top) {\n      var fill = filloptions.fill;\n      if (!fill) return null;\n      if (filloptions.fillColor) return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);\n      var c = $.color.parse(seriesColor);\n      c.a = typeof fill == \"number\" ? fill : 0.4;\n      c.normalize();\n      return c.toString();\n    }\n    function insertLegend() {\n      if (options.legend.container != null) {\n        $(options.legend.container).html(\"\");\n      } else {\n        placeholder.find(\".legend\").remove();\n      }\n      if (!options.legend.show) {\n        return;\n      }\n      var fragments = [],\n        entries = [],\n        rowStarted = false,\n        lf = options.legend.labelFormatter,\n        s,\n        label;\n\n      for (var i = 0; i < series.length; ++i) {\n        s = series[i];\n        if (s.label) {\n          label = lf ? lf(s.label, s) : s.label;\n          if (label) {\n            entries.push({\n              label: label,\n              color: s.color\n            });\n          }\n        }\n      }\n\n      if (options.legend.sorted) {\n        if ($.isFunction(options.legend.sorted)) {\n          entries.sort(options.legend.sorted);\n        } else if (options.legend.sorted == \"reverse\") {\n          entries.reverse();\n        } else {\n          var ascending = options.legend.sorted != \"descending\";\n          entries.sort(function (a, b) {\n            return a.label == b.label ? 0 : a.label < b.label != ascending ? 1 : -1;\n          });\n        }\n      }\n\n      for (var i = 0; i < entries.length; ++i) {\n        var entry = entries[i];\n        if (i % options.legend.noColumns == 0) {\n          if (rowStarted) fragments.push('</tr>');\n          fragments.push('<tr>');\n          rowStarted = true;\n        }\n        fragments.push('<td class=\"legendColorBox\"><div style=\"border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px\"><div style=\"width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden\"></div></div></td>' + '<td class=\"legendLabel\">' + entry.label + '</td>');\n      }\n      if (rowStarted) fragments.push('</tr>');\n      if (fragments.length == 0) return;\n      var table = '<table style=\"font-size:smaller;color:' + options.grid.color + '\">' + fragments.join(\"\") + '</table>';\n      if (options.legend.container != null) $(options.legend.container).html(table);else {\n        var pos = \"\",\n          p = options.legend.position,\n          m = options.legend.margin;\n        if (m[0] == null) m = [m, m];\n        if (p.charAt(0) == \"n\") pos += 'top:' + (m[1] + plotOffset.top) + 'px;';else if (p.charAt(0) == \"s\") pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';\n        if (p.charAt(1) == \"e\") pos += 'right:' + (m[0] + plotOffset.right) + 'px;';else if (p.charAt(1) == \"w\") pos += 'left:' + (m[0] + plotOffset.left) + 'px;';\n        var legend = $('<div class=\"legend\">' + table.replace('style=\"', 'style=\"position:absolute;' + pos + ';') + '</div>').appendTo(placeholder);\n        if (options.legend.backgroundOpacity != 0.0) {\n          var c = options.legend.backgroundColor;\n          if (c == null) {\n            c = options.grid.backgroundColor;\n            if (c && typeof c == \"string\") c = $.color.parse(c);else c = $.color.extract(legend, 'background-color');\n            c.a = 1;\n            c = c.toString();\n          }\n          var div = legend.children();\n          $('<div style=\"position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos + 'background-color:' + c + ';\"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);\n        }\n      }\n    }\n\n    var highlights = [],\n      redrawTimeout = null;\n\n    function findNearbyItem(mouseX, mouseY, seriesFilter) {\n      var maxDistance = options.grid.mouseActiveRadius,\n        smallestDistance = maxDistance * maxDistance + 1,\n        item = null,\n        foundPoint = false,\n        i,\n        j,\n        ps;\n      for (i = series.length - 1; i >= 0; --i) {\n        if (!seriesFilter(series[i])) continue;\n        var s = series[i],\n          axisx = s.xaxis,\n          axisy = s.yaxis,\n          points = s.datapoints.points,\n          mx = axisx.c2p(mouseX),\n          my = axisy.c2p(mouseY),\n          maxx = maxDistance / axisx.scale,\n          maxy = maxDistance / axisy.scale;\n        ps = s.datapoints.pointsize;\n        if (axisx.options.inverseTransform) maxx = Number.MAX_VALUE;\n        if (axisy.options.inverseTransform) maxy = Number.MAX_VALUE;\n        if (s.lines.show || s.points.show) {\n          for (j = 0; j < points.length; j += ps) {\n            var x = points[j],\n              y = points[j + 1];\n            if (x == null) continue;\n\n            if (x - mx > maxx || x - mx < -maxx || y - my > maxy || y - my < -maxy) continue;\n\n            var dx = Math.abs(axisx.p2c(x) - mouseX),\n              dy = Math.abs(axisy.p2c(y) - mouseY),\n              dist = dx * dx + dy * dy;\n\n            if (dist < smallestDistance) {\n              smallestDistance = dist;\n              item = [i, j / ps];\n            }\n          }\n        }\n        if (s.bars.show && !item) {\n\n          var barLeft, barRight;\n          switch (s.bars.align) {\n            case \"left\":\n              barLeft = 0;\n              break;\n            case \"right\":\n              barLeft = -s.bars.barWidth;\n              break;\n            default:\n              barLeft = -s.bars.barWidth / 2;\n          }\n          barRight = barLeft + s.bars.barWidth;\n          for (j = 0; j < points.length; j += ps) {\n            var x = points[j],\n              y = points[j + 1],\n              b = points[j + 2];\n            if (x == null) continue;\n\n            if (series[i].bars.horizontal ? mx <= Math.max(b, x) && mx >= Math.min(b, x) && my >= y + barLeft && my <= y + barRight : mx >= x + barLeft && mx <= x + barRight && my >= Math.min(b, y) && my <= Math.max(b, y)) item = [i, j / ps];\n          }\n        }\n      }\n      if (item) {\n        i = item[0];\n        j = item[1];\n        ps = series[i].datapoints.pointsize;\n        return {\n          datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),\n          dataIndex: j,\n          series: series[i],\n          seriesIndex: i\n        };\n      }\n      return null;\n    }\n    function onMouseMove(e) {\n      if (options.grid.hoverable) triggerClickHoverEvent(\"plothover\", e, function (s) {\n        return s[\"hoverable\"] != false;\n      });\n    }\n    function onMouseLeave(e) {\n      if (options.grid.hoverable) triggerClickHoverEvent(\"plothover\", e, function (s) {\n        return false;\n      });\n    }\n    function onClick(e) {\n      triggerClickHoverEvent(\"plotclick\", e, function (s) {\n        return s[\"clickable\"] != false;\n      });\n    }\n\n    function triggerClickHoverEvent(eventname, event, seriesFilter) {\n      var offset = eventHolder.offset(),\n        canvasX = event.pageX - offset.left - plotOffset.left,\n        canvasY = event.pageY - offset.top - plotOffset.top,\n        pos = canvasToAxisCoords({\n          left: canvasX,\n          top: canvasY\n        });\n      pos.pageX = event.pageX;\n      pos.pageY = event.pageY;\n      var item = findNearbyItem(canvasX, canvasY, seriesFilter);\n      if (item) {\n        item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);\n        item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);\n      }\n      if (options.grid.autoHighlight) {\n        for (var i = 0; i < highlights.length; ++i) {\n          var h = highlights[i];\n          if (h.auto == eventname && !(item && h.series == item.series && h.point[0] == item.datapoint[0] && h.point[1] == item.datapoint[1])) unhighlight(h.series, h.point);\n        }\n        if (item) highlight(item.series, item.datapoint, eventname);\n      }\n      placeholder.trigger(eventname, [pos, item]);\n    }\n    function triggerRedrawOverlay() {\n      var t = options.interaction.redrawOverlayInterval;\n      if (t == -1) {\n        drawOverlay();\n        return;\n      }\n      if (!redrawTimeout) redrawTimeout = setTimeout(drawOverlay, t);\n    }\n    function drawOverlay() {\n      redrawTimeout = null;\n\n      octx.save();\n      overlay.clear();\n      octx.translate(plotOffset.left, plotOffset.top);\n      var i, hi;\n      for (i = 0; i < highlights.length; ++i) {\n        hi = highlights[i];\n        if (hi.series.bars.show) drawBarHighlight(hi.series, hi.point);else drawPointHighlight(hi.series, hi.point);\n      }\n      octx.restore();\n      executeHooks(hooks.drawOverlay, [octx]);\n    }\n    function highlight(s, point, auto) {\n      if (typeof s == \"number\") s = series[s];\n      if (typeof point == \"number\") {\n        var ps = s.datapoints.pointsize;\n        point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n      }\n      var i = indexOfHighlight(s, point);\n      if (i == -1) {\n        highlights.push({\n          series: s,\n          point: point,\n          auto: auto\n        });\n        triggerRedrawOverlay();\n      } else if (!auto) highlights[i].auto = false;\n    }\n    function unhighlight(s, point) {\n      if (s == null && point == null) {\n        highlights = [];\n        triggerRedrawOverlay();\n        return;\n      }\n      if (typeof s == \"number\") s = series[s];\n      if (typeof point == \"number\") {\n        var ps = s.datapoints.pointsize;\n        point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n      }\n      var i = indexOfHighlight(s, point);\n      if (i != -1) {\n        highlights.splice(i, 1);\n        triggerRedrawOverlay();\n      }\n    }\n    function indexOfHighlight(s, p) {\n      for (var i = 0; i < highlights.length; ++i) {\n        var h = highlights[i];\n        if (h.series == s && h.point[0] == p[0] && h.point[1] == p[1]) return i;\n      }\n      return -1;\n    }\n    function drawPointHighlight(series, point) {\n      var x = point[0],\n        y = point[1],\n        axisx = series.xaxis,\n        axisy = series.yaxis,\n        highlightColor = typeof series.highlightColor === \"string\" ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();\n      if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max) return;\n      var pointRadius = series.points.radius + series.points.lineWidth / 2;\n      octx.lineWidth = pointRadius;\n      octx.strokeStyle = highlightColor;\n      var radius = 1.5 * pointRadius;\n      x = axisx.p2c(x);\n      y = axisy.p2c(y);\n      octx.beginPath();\n      if (series.points.symbol == \"circle\") octx.arc(x, y, radius, 0, 2 * Math.PI, false);else series.points.symbol(octx, x, y, radius, false);\n      octx.closePath();\n      octx.stroke();\n    }\n    function drawBarHighlight(series, point) {\n      var highlightColor = typeof series.highlightColor === \"string\" ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),\n        fillStyle = highlightColor,\n        barLeft;\n      switch (series.bars.align) {\n        case \"left\":\n          barLeft = 0;\n          break;\n        case \"right\":\n          barLeft = -series.bars.barWidth;\n          break;\n        default:\n          barLeft = -series.bars.barWidth / 2;\n      }\n      octx.lineWidth = series.bars.lineWidth;\n      octx.strokeStyle = highlightColor;\n      drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth, function () {\n        return fillStyle;\n      }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);\n    }\n    function getColorOrGradient(spec, bottom, top, defaultColor) {\n      if (typeof spec == \"string\") return spec;else {\n        var gradient = ctx.createLinearGradient(0, top, 0, bottom);\n        for (var i = 0, l = spec.colors.length; i < l; ++i) {\n          var c = spec.colors[i];\n          if (typeof c != \"string\") {\n            var co = $.color.parse(defaultColor);\n            if (c.brightness != null) co = co.scale('rgb', c.brightness);\n            if (c.opacity != null) co.a *= c.opacity;\n            c = co.toString();\n          }\n          gradient.addColorStop(i / (l - 1), c);\n        }\n        return gradient;\n      }\n    }\n  }\n\n  $.plot = function (placeholder, data, options) {\n    var plot = new Plot($(placeholder), data, options, $.plot.plugins);\n    return plot;\n  };\n  $.plot.version = \"0.8.3\";\n  $.plot.plugins = [];\n\n  $.fn.plot = function (data, options) {\n    return this.each(function () {\n      $.plot(this, data, options);\n    });\n  };\n\n  function floorInBase(n, base) {\n    return base * Math.floor(n / base);\n  }\n})(jQuery);","map":{"version":3,"names":["$","color","make","r","g","b","a","o","add","c","d","i","length","charAt","normalize","scale","f","toString","join","clamp","min","value","max","parseInt","clone","extract","elem","css","toLowerCase","parent","nodeName","get","parse","str","res","m","exec","parseFloat","name","trim","lookupColors","aqua","azure","beige","black","blue","brown","cyan","darkblue","darkcyan","darkgrey","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkviolet","fuchsia","gold","green","indigo","khaki","lightblue","lightcyan","lightgreen","lightgrey","lightpink","lightyellow","lime","magenta","maroon","navy","olive","orange","pink","purple","violet","red","silver","white","yellow","jQuery","hasOwnProperty","Object","prototype","fn","detach","each","parentNode","removeChild","Canvas","cls","container","element","children","document","createElement","className","direction","position","left","top","appendTo","getContext","window","G_vmlCanvasManager","initElement","Error","context","devicePixelRatio","backingStoreRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","pixelRatio","resize","width","height","textContainer","text","_textCache","style","restore","save","clear","clearRect","render","cache","layerKey","call","layer","getTextLayer","layerCache","hide","styleKey","styleCache","key","positions","active","rendered","append","splice","show","classes","bottom","right","insertAfter","addClass","getTextInfo","font","angle","textStyle","info","variant","weight","size","lineHeight","family","html","outerWidth","outerHeight","addText","x","y","halign","valign","push","Math","round","removeText","Plot","placeholder","data_","options_","plugins","series","options","colors","legend","noColumns","labelFormatter","labelBoxBorderColor","margin","backgroundColor","backgroundOpacity","sorted","xaxis","mode","tickColor","transform","inverseTransform","autoscaleMargin","ticks","tickFormatter","labelWidth","labelHeight","reserveSpace","tickLength","alignTicksWithAxis","tickDecimals","tickSize","minTickSize","yaxis","xaxes","yaxes","points","radius","lineWidth","fill","fillColor","symbol","lines","steps","bars","barWidth","align","horizontal","zero","shadowSize","highlightColor","grid","aboveData","borderColor","labelMargin","axisMargin","borderWidth","minBorderMargin","markings","markingsColor","markingsLineWidth","clickable","hoverable","autoHighlight","mouseActiveRadius","interaction","redrawOverlayInterval","hooks","surface","overlay","eventHolder","ctx","octx","plotOffset","plotWidth","plotHeight","processOptions","processRawData","processDatapoints","processOffset","drawBackground","drawSeries","draw","bindEvents","drawOverlay","shutdown","plot","setData","setupGrid","getPlaceholder","getCanvas","getPlotOffset","offset","getData","getAxes","concat","_","axis","n","getXAxes","getYAxes","c2p","canvasToAxisCoords","p2c","axisToCanvasCoords","getOptions","highlight","unhighlight","triggerRedrawOverlay","pointOffset","point","axisNumber","destroy","removeData","empty","highlights","initPlugins","parseOptions","setupCanvases","executeHooks","hook","args","apply","p","init","extend","opts","axisOptions","axisCount","fontSize","fontSizeDefault","replace","fontDefaults","noTicks","x2axis","y2axis","coloredAreas","coloredAreasColor","getOrCreateAxis","parseData","fillInSeriesOptions","processData","s","data","obj","coord","allAxes","grep","pos","used","x1","undefined","y1","axes","number","neededColors","maxIndex","sc","colorPool","colorPoolSize","variation","colori","v","topSentry","Number","POSITIVE_INFINITY","bottomSentry","NEGATIVE_INFINITY","fakeInfinity","MAX_VALUE","j","k","ps","val","format","updateAxis","datamin","datamax","datapoints","required","autoscale","defaultValue","pointsize","insertSteps","nullify","isNaN","Infinity","xmin","ymin","xmax","ymax","delta","filter","hasClass","remove","unbind","existing","mousemove","onMouseMove","bind","onMouseLeave","click","onClick","redrawTimeout","clearTimeout","setTransformationHelpers","identity","t","it","abs","measureTickLabels","maxWidth","floor","legacyStyles","label","allocateAxisBoxFirstPhase","lw","lh","isXAxis","padding","innermost","outermost","first","found","box","allocateAxisBoxSecondPhase","adjustLayoutForThingsStickingOut","minMargin","margins","ceil","showGrid","axisOpts","setRange","allocatedAxes","setupTickGeneration","setTicks","snapRangeToTicks","drawAxisLabels","insertLegend","widen","sqrt","dec","log","LN10","maxDec","magn","pow","norm","tickGenerator","start","floorInBase","NaN","prev","factor","formatted","decimal","indexOf","precision","substr","isFunction","otherAxis","niceTicks","extraDec","ts","test","toFixed","oticks","drawGrid","extractRange","ranges","from","to","tmp","translate","fillStyle","getColorOrGradient","fillRect","bw","bc","xrange","yrange","xequal","yequal","subPixel","beginPath","strokeStyle","moveTo","lineTo","stroke","xoff","yoff","strokeRect","tick","drawSeriesLines","drawSeriesBars","drawSeriesPoints","plotLine","xoffset","yoffset","axisx","axisy","prevx","prevy","x2","y2","plotLineArea","areaOpen","ypos","segmentStart","segmentEnd","x1old","x2old","lineJoin","sw","PI","sin","cos","getFillStyle","plotPoints","shadow","arc","closePath","w","drawBar","barLeft","barRight","fillStyleCallback","drawLeft","drawRight","drawTop","drawBottom","plotBars","filloptions","seriesColor","find","fragments","entries","rowStarted","lf","sort","reverse","ascending","entry","table","div","prependTo","findNearbyItem","mouseX","mouseY","seriesFilter","maxDistance","smallestDistance","item","foundPoint","mx","my","maxx","maxy","dx","dy","dist","datapoint","slice","dataIndex","seriesIndex","e","triggerClickHoverEvent","eventname","event","canvasX","pageX","canvasY","pageY","h","auto","trigger","setTimeout","hi","drawBarHighlight","drawPointHighlight","indexOfHighlight","pointRadius","spec","defaultColor","gradient","createLinearGradient","l","co","brightness","opacity","addColorStop","version","base"],"sources":["/Users/peterputros/Desktop/PosMate/assets/plugins/flot/jquery.flot.js"],"sourcesContent":["/* Javascript plotting library for jQuery, version 0.8.3.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\n*/\n\n// first an inline dependency, jquery.colorhelpers.js, we inline it here\n// for convenience\n\n/* Plugin for jQuery for working with colors.\n *\n * Version 1.1.\n *\n * Inspiration from jQuery color animation plugin by John Resig.\n *\n * Released under the MIT license by Ole Laursen, October 2009.\n *\n * Examples:\n *\n *   $.color.parse(\"#fff\").scale('rgb', 0.25).add('a', -0.5).toString()\n *   var c = $.color.extract($(\"#mydiv\"), 'background-color');\n *   console.log(c.r, c.g, c.b, c.a);\n *   $.color.make(100, 50, 25, 0.4).toString() // returns \"rgba(100,50,25,0.4)\"\n *\n * Note that .scale() and .add() return the same modified object\n * instead of making a new one.\n *\n * V. 1.1: Fix error handling so e.g. parsing an empty string does\n * produce a color rather than just crashing.\n */\n(function($){$.color={};$.color.make=function(r,g,b,a){var o={};o.r=r||0;o.g=g||0;o.b=b||0;o.a=a!=null?a:1;o.add=function(c,d){for(var i=0;i<c.length;++i)o[c.charAt(i)]+=d;return o.normalize()};o.scale=function(c,f){for(var i=0;i<c.length;++i)o[c.charAt(i)]*=f;return o.normalize()};o.toString=function(){if(o.a>=1){return\"rgb(\"+[o.r,o.g,o.b].join(\",\")+\")\"}else{return\"rgba(\"+[o.r,o.g,o.b,o.a].join(\",\")+\")\"}};o.normalize=function(){function clamp(min,value,max){return value<min?min:value>max?max:value}o.r=clamp(0,parseInt(o.r),255);o.g=clamp(0,parseInt(o.g),255);o.b=clamp(0,parseInt(o.b),255);o.a=clamp(0,o.a,1);return o};o.clone=function(){return $.color.make(o.r,o.b,o.g,o.a)};return o.normalize()};$.color.extract=function(elem,css){var c;do{c=elem.css(css).toLowerCase();if(c!=\"\"&&c!=\"transparent\")break;elem=elem.parent()}while(elem.length&&!$.nodeName(elem.get(0),\"body\"));if(c==\"rgba(0, 0, 0, 0)\")c=\"transparent\";return $.color.parse(c)};$.color.parse=function(str){var res,m=$.color.make;if(res=/rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10));if(res=/rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10),parseFloat(res[4]));if(res=/rgb\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*\\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55);if(res=/rgba\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55,parseFloat(res[4]));if(res=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str))return m(parseInt(res[1],16),parseInt(res[2],16),parseInt(res[3],16));if(res=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str))return m(parseInt(res[1]+res[1],16),parseInt(res[2]+res[2],16),parseInt(res[3]+res[3],16));var name=$.trim(str).toLowerCase();if(name==\"transparent\")return m(255,255,255,0);else{res=lookupColors[name]||[0,0,0];return m(res[0],res[1],res[2])}};var lookupColors={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]}})(jQuery);\n\n// the actual Flot code\n(function($) {\n\n\t// Cache the prototype hasOwnProperty for faster access\n\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    // A shim to provide 'detach' to jQuery versions prior to 1.4.  Using a DOM\n    // operation produces the same effect as detach, i.e. removing the element\n    // without touching its jQuery data.\n\n    // Do not merge this into Flot 0.9, since it requires jQuery 1.4.4+.\n\n    if (!$.fn.detach) {\n        $.fn.detach = function() {\n            return this.each(function() {\n                if (this.parentNode) {\n                    this.parentNode.removeChild( this );\n                }\n            });\n        };\n    }\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// The Canvas object is a wrapper around an HTML5 <canvas> tag.\n\t//\n\t// @constructor\n\t// @param {string} cls List of classes to apply to the canvas.\n\t// @param {element} container Element onto which to append the canvas.\n\t//\n\t// Requiring a container is a little iffy, but unfortunately canvas\n\t// operations don't work unless the canvas is attached to the DOM.\n\n\tfunction Canvas(cls, container) {\n\n\t\tvar element = container.children(\".\" + cls)[0];\n\n\t\tif (element == null) {\n\n\t\t\telement = document.createElement(\"canvas\");\n\t\t\telement.className = cls;\n\n\t\t\t$(element).css({ direction: \"ltr\", position: \"absolute\", left: 0, top: 0 })\n\t\t\t\t.appendTo(container);\n\n\t\t\t// If HTML5 Canvas isn't available, fall back to [Ex|Flash]canvas\n\n\t\t\tif (!element.getContext) {\n\t\t\t\tif (window.G_vmlCanvasManager) {\n\t\t\t\t\telement = window.G_vmlCanvasManager.initElement(element);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.element = element;\n\n\t\tvar context = this.context = element.getContext(\"2d\");\n\n\t\t// Determine the screen's ratio of physical to device-independent\n\t\t// pixels.  This is the ratio between the canvas width that the browser\n\t\t// advertises and the number of pixels actually present in that space.\n\n\t\t// The iPhone 4, for example, has a device-independent width of 320px,\n\t\t// but its screen is actually 640px wide.  It therefore has a pixel\n\t\t// ratio of 2, while most normal devices have a ratio of 1.\n\n\t\tvar devicePixelRatio = window.devicePixelRatio || 1,\n\t\t\tbackingStoreRatio =\n\t\t\t\tcontext.webkitBackingStorePixelRatio ||\n\t\t\t\tcontext.mozBackingStorePixelRatio ||\n\t\t\t\tcontext.msBackingStorePixelRatio ||\n\t\t\t\tcontext.oBackingStorePixelRatio ||\n\t\t\t\tcontext.backingStorePixelRatio || 1;\n\n\t\tthis.pixelRatio = devicePixelRatio / backingStoreRatio;\n\n\t\t// Size the canvas to match the internal dimensions of its container\n\n\t\tthis.resize(container.width(), container.height());\n\n\t\t// Collection of HTML div layers for text overlaid onto the canvas\n\n\t\tthis.textContainer = null;\n\t\tthis.text = {};\n\n\t\t// Cache of text fragments and metrics, so we can avoid expensively\n\t\t// re-calculating them when the plot is re-rendered in a loop.\n\n\t\tthis._textCache = {};\n\t}\n\n\t// Resizes the canvas to the given dimensions.\n\t//\n\t// @param {number} width New width of the canvas, in pixels.\n\t// @param {number} width New height of the canvas, in pixels.\n\n\tCanvas.prototype.resize = function(width, height) {\n\n\t\tif (width <= 0 || height <= 0) {\n\t\t\tthrow new Error(\"Invalid dimensions for plot, width = \" + width + \", height = \" + height);\n\t\t}\n\n\t\tvar element = this.element,\n\t\t\tcontext = this.context,\n\t\t\tpixelRatio = this.pixelRatio;\n\n\t\t// Resize the canvas, increasing its density based on the display's\n\t\t// pixel ratio; basically giving it more pixels without increasing the\n\t\t// size of its element, to take advantage of the fact that retina\n\t\t// displays have that many more pixels in the same advertised space.\n\n\t\t// Resizing should reset the state (excanvas seems to be buggy though)\n\n\t\tif (this.width != width) {\n\t\t\telement.width = width * pixelRatio;\n\t\t\telement.style.width = width + \"px\";\n\t\t\tthis.width = width;\n\t\t}\n\n\t\tif (this.height != height) {\n\t\t\telement.height = height * pixelRatio;\n\t\t\telement.style.height = height + \"px\";\n\t\t\tthis.height = height;\n\t\t}\n\n\t\t// Save the context, so we can reset in case we get replotted.  The\n\t\t// restore ensure that we're really back at the initial state, and\n\t\t// should be safe even if we haven't saved the initial state yet.\n\n\t\tcontext.restore();\n\t\tcontext.save();\n\n\t\t// Scale the coordinate space to match the display density; so even though we\n\t\t// may have twice as many pixels, we still want lines and other drawing to\n\t\t// appear at the same size; the extra pixels will just make them crisper.\n\n\t\tcontext.scale(pixelRatio, pixelRatio);\n\t};\n\n\t// Clears the entire canvas area, not including any overlaid HTML text\n\n\tCanvas.prototype.clear = function() {\n\t\tthis.context.clearRect(0, 0, this.width, this.height);\n\t};\n\n\t// Finishes rendering the canvas, including managing the text overlay.\n\n\tCanvas.prototype.render = function() {\n\n\t\tvar cache = this._textCache;\n\n\t\t// For each text layer, add elements marked as active that haven't\n\t\t// already been rendered, and remove those that are no longer active.\n\n\t\tfor (var layerKey in cache) {\n\t\t\tif (hasOwnProperty.call(cache, layerKey)) {\n\n\t\t\t\tvar layer = this.getTextLayer(layerKey),\n\t\t\t\t\tlayerCache = cache[layerKey];\n\n\t\t\t\tlayer.hide();\n\n\t\t\t\tfor (var styleKey in layerCache) {\n\t\t\t\t\tif (hasOwnProperty.call(layerCache, styleKey)) {\n\t\t\t\t\t\tvar styleCache = layerCache[styleKey];\n\t\t\t\t\t\tfor (var key in styleCache) {\n\t\t\t\t\t\t\tif (hasOwnProperty.call(styleCache, key)) {\n\n\t\t\t\t\t\t\t\tvar positions = styleCache[key].positions;\n\n\t\t\t\t\t\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\t\t\t\t\t\tif (position.active) {\n\t\t\t\t\t\t\t\t\t\tif (!position.rendered) {\n\t\t\t\t\t\t\t\t\t\t\tlayer.append(position.element);\n\t\t\t\t\t\t\t\t\t\t\tposition.rendered = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpositions.splice(i--, 1);\n\t\t\t\t\t\t\t\t\t\tif (position.rendered) {\n\t\t\t\t\t\t\t\t\t\t\tposition.element.detach();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (positions.length == 0) {\n\t\t\t\t\t\t\t\t\tdelete styleCache[key];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlayer.show();\n\t\t\t}\n\t\t}\n\t};\n\n\t// Creates (if necessary) and returns the text overlay container.\n\t//\n\t// @param {string} classes String of space-separated CSS classes used to\n\t//     uniquely identify the text layer.\n\t// @return {object} The jQuery-wrapped text-layer div.\n\n\tCanvas.prototype.getTextLayer = function(classes) {\n\n\t\tvar layer = this.text[classes];\n\n\t\t// Create the text layer if it doesn't exist\n\n\t\tif (layer == null) {\n\n\t\t\t// Create the text layer container, if it doesn't exist\n\n\t\t\tif (this.textContainer == null) {\n\t\t\t\tthis.textContainer = $(\"<div class='flot-text'></div>\")\n\t\t\t\t\t.css({\n\t\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\tbottom: 0,\n\t\t\t\t\t\tright: 0,\n\t\t\t\t\t\t'font-size': \"smaller\",\n\t\t\t\t\t\tcolor: \"#545454\"\n\t\t\t\t\t})\n\t\t\t\t\t.insertAfter(this.element);\n\t\t\t}\n\n\t\t\tlayer = this.text[classes] = $(\"<div></div>\")\n\t\t\t\t.addClass(classes)\n\t\t\t\t.css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\ttop: 0,\n\t\t\t\t\tleft: 0,\n\t\t\t\t\tbottom: 0,\n\t\t\t\t\tright: 0\n\t\t\t\t})\n\t\t\t\t.appendTo(this.textContainer);\n\t\t}\n\n\t\treturn layer;\n\t};\n\n\t// Creates (if necessary) and returns a text info object.\n\t//\n\t// The object looks like this:\n\t//\n\t// {\n\t//     width: Width of the text's wrapper div.\n\t//     height: Height of the text's wrapper div.\n\t//     element: The jQuery-wrapped HTML div containing the text.\n\t//     positions: Array of positions at which this text is drawn.\n\t// }\n\t//\n\t// The positions array contains objects that look like this:\n\t//\n\t// {\n\t//     active: Flag indicating whether the text should be visible.\n\t//     rendered: Flag indicating whether the text is currently visible.\n\t//     element: The jQuery-wrapped HTML div containing the text.\n\t//     x: X coordinate at which to draw the text.\n\t//     y: Y coordinate at which to draw the text.\n\t// }\n\t//\n\t// Each position after the first receives a clone of the original element.\n\t//\n\t// The idea is that that the width, height, and general 'identity' of the\n\t// text is constant no matter where it is placed; the placements are a\n\t// secondary property.\n\t//\n\t// Canvas maintains a cache of recently-used text info objects; getTextInfo\n\t// either returns the cached element or creates a new entry.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {string} text Text string to retrieve info for.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which to rotate the text, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\t// @param {number=} width Maximum width of the text before it wraps.\n\t// @return {object} a text info object.\n\n\tCanvas.prototype.getTextInfo = function(layer, text, font, angle, width) {\n\n\t\tvar textStyle, layerCache, styleCache, info;\n\n\t\t// Cast the value to a string, in case we were given a number or such\n\n\t\ttext = \"\" + text;\n\n\t\t// If the font is a font-spec object, generate a CSS font definition\n\n\t\tif (typeof font === \"object\") {\n\t\t\ttextStyle = font.style + \" \" + font.variant + \" \" + font.weight + \" \" + font.size + \"px/\" + font.lineHeight + \"px \" + font.family;\n\t\t} else {\n\t\t\ttextStyle = font;\n\t\t}\n\n\t\t// Retrieve (or create) the cache for the text's layer and styles\n\n\t\tlayerCache = this._textCache[layer];\n\n\t\tif (layerCache == null) {\n\t\t\tlayerCache = this._textCache[layer] = {};\n\t\t}\n\n\t\tstyleCache = layerCache[textStyle];\n\n\t\tif (styleCache == null) {\n\t\t\tstyleCache = layerCache[textStyle] = {};\n\t\t}\n\n\t\tinfo = styleCache[text];\n\n\t\t// If we can't find a matching element in our cache, create a new one\n\n\t\tif (info == null) {\n\n\t\t\tvar element = $(\"<div></div>\").html(text)\n\t\t\t\t.css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\t'max-width': width,\n\t\t\t\t\ttop: -9999\n\t\t\t\t})\n\t\t\t\t.appendTo(this.getTextLayer(layer));\n\n\t\t\tif (typeof font === \"object\") {\n\t\t\t\telement.css({\n\t\t\t\t\tfont: textStyle,\n\t\t\t\t\tcolor: font.color\n\t\t\t\t});\n\t\t\t} else if (typeof font === \"string\") {\n\t\t\t\telement.addClass(font);\n\t\t\t}\n\n\t\t\tinfo = styleCache[text] = {\n\t\t\t\twidth: element.outerWidth(true),\n\t\t\t\theight: element.outerHeight(true),\n\t\t\t\telement: element,\n\t\t\t\tpositions: []\n\t\t\t};\n\n\t\t\telement.detach();\n\t\t}\n\n\t\treturn info;\n\t};\n\n\t// Adds a text string to the canvas text overlay.\n\t//\n\t// The text isn't drawn immediately; it is marked as rendering, which will\n\t// result in its addition to the canvas on the next render pass.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {number} x X coordinate at which to draw the text.\n\t// @param {number} y Y coordinate at which to draw the text.\n\t// @param {string} text Text string to draw.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which to rotate the text, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\t// @param {number=} width Maximum width of the text before it wraps.\n\t// @param {string=} halign Horizontal alignment of the text; either \"left\",\n\t//     \"center\" or \"right\".\n\t// @param {string=} valign Vertical alignment of the text; either \"top\",\n\t//     \"middle\" or \"bottom\".\n\n\tCanvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign) {\n\n\t\tvar info = this.getTextInfo(layer, text, font, angle, width),\n\t\t\tpositions = info.positions;\n\n\t\t// Tweak the div's position to match the text's alignment\n\n\t\tif (halign == \"center\") {\n\t\t\tx -= info.width / 2;\n\t\t} else if (halign == \"right\") {\n\t\t\tx -= info.width;\n\t\t}\n\n\t\tif (valign == \"middle\") {\n\t\t\ty -= info.height / 2;\n\t\t} else if (valign == \"bottom\") {\n\t\t\ty -= info.height;\n\t\t}\n\n\t\t// Determine whether this text already exists at this position.\n\t\t// If so, mark it for inclusion in the next render pass.\n\n\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\tif (position.x == x && position.y == y) {\n\t\t\t\tposition.active = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If the text doesn't exist at this position, create a new entry\n\n\t\t// For the very first position we'll re-use the original element,\n\t\t// while for subsequent ones we'll clone it.\n\n\t\tposition = {\n\t\t\tactive: true,\n\t\t\trendered: false,\n\t\t\telement: positions.length ? info.element.clone() : info.element,\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\n\t\tpositions.push(position);\n\n\t\t// Move the element to its final position within the container\n\n\t\tposition.element.css({\n\t\t\ttop: Math.round(y),\n\t\t\tleft: Math.round(x),\n\t\t\t'text-align': halign\t// In case the text wraps\n\t\t});\n\t};\n\n\t// Removes one or more text strings from the canvas text overlay.\n\t//\n\t// If no parameters are given, all text within the layer is removed.\n\t//\n\t// Note that the text is not immediately removed; it is simply marked as\n\t// inactive, which will result in its removal on the next render pass.\n\t// This avoids the performance penalty for 'clear and redraw' behavior,\n\t// where we potentially get rid of all text on a layer, but will likely\n\t// add back most or all of it later, as when redrawing axes, for example.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {number=} x X coordinate of the text.\n\t// @param {number=} y Y coordinate of the text.\n\t// @param {string=} text Text string to remove.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which the text is rotated, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\n\tCanvas.prototype.removeText = function(layer, x, y, text, font, angle) {\n\t\tif (text == null) {\n\t\t\tvar layerCache = this._textCache[layer];\n\t\t\tif (layerCache != null) {\n\t\t\t\tfor (var styleKey in layerCache) {\n\t\t\t\t\tif (hasOwnProperty.call(layerCache, styleKey)) {\n\t\t\t\t\t\tvar styleCache = layerCache[styleKey];\n\t\t\t\t\t\tfor (var key in styleCache) {\n\t\t\t\t\t\t\tif (hasOwnProperty.call(styleCache, key)) {\n\t\t\t\t\t\t\t\tvar positions = styleCache[key].positions;\n\t\t\t\t\t\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\t\t\t\t\t\tposition.active = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar positions = this.getTextInfo(layer, text, font, angle).positions;\n\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\tif (position.x == x && position.y == y) {\n\t\t\t\t\tposition.active = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// The top-level container for the entire plot.\n\n    function Plot(placeholder, data_, options_, plugins) {\n        // data is on the form:\n        //   [ series1, series2 ... ]\n        // where series is either just the data as [ [x1, y1], [x2, y2], ... ]\n        // or { data: [ [x1, y1], [x2, y2], ... ], label: \"some label\", ... }\n\n        var series = [],\n            options = {\n                // the color theme used for graphs\n                colors: [\"#fa057a\", \"#f72d66\", \"#f7be2d\", \"#2dcbf7\", \"#64E572\"],\n                legend: {\n                    show: true,\n                    noColumns: 1, // number of colums in legend table\n                    labelFormatter: null, // fn: string -> string\n                    labelBoxBorderColor: \"transparent\", // border color for the little label boxes\n                    container: null, // container (as jQuery object) to put legend in, null means default on top of graph\n                    position: \"ne\", // position of default legend container within plot\n                    margin: 5, // distance from grid edge to default legend container within plot\n                    backgroundColor: null, // null means auto-detect\n                    backgroundOpacity: 0.85, // set to 0 to avoid background\n                    sorted: null    // default to no legend sorting\n                },\n                xaxis: {\n                    show: null, // null = auto-detect, true = always, false = never\n                    position: \"bottom\", // or \"top\"\n                    mode: null, // null or \"time\"\n                    font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: \"italic\", weight: \"bold\", family: \"sans-serif\", variant: \"small-caps\" }\n                    color: null, // base color, labels, ticks\n                    tickColor: null, // possibly different color of ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    transform: null, // null or f: number -> number to transform axis\n                    inverseTransform: null, // if transform is set, this should be the inverse function\n                    min: null, // min. value to show, null means set automatically\n                    max: null, // max. value to show, null means set automatically\n                    autoscaleMargin: null, // margin in % to add if auto-setting min/max\n                    ticks: null, // either [1, 3] or [[1, \"a\"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks\n                    tickFormatter: null, // fn: number -> string\n                    labelWidth: null, // size of tick labels in pixels\n                    labelHeight: null,\n                    reserveSpace: null, // whether to reserve space even if axis isn't shown\n                    tickLength: null, // size in pixels of ticks, or \"full\" for whole line\n                    alignTicksWithAxis: null, // axis number or null for no sync\n                    tickDecimals: null, // no. of decimals, null means auto\n                    tickSize: null, // number or [number, \"unit\"]\n                    minTickSize: null // number or [number, \"unit\"]\n                },\n                yaxis: {\n                    autoscaleMargin: 0.02,\n                    position: \"left\" // or \"right\"\n                },\n                xaxes: [],\n                yaxes: [],\n                series: {\n                    points: {\n                        show: false,\n                        radius: 3,\n                        lineWidth: 2, // in pixels\n                        fill: true,\n                        fillColor: \"#ffffff\",\n                        symbol: \"circle\" // or callback\n                    },\n                    lines: {\n                        // we don't put in show: false so we can see\n                        // whether lines were actively disabled\n                        lineWidth: 2, // in pixels\n                        fill: false,\n                        fillColor: null,\n                        steps: false\n                        // Omit 'zero', so we can later default its value to\n                        // match that of the 'fill' option.\n                    },\n                    bars: {\n                        show: false,\n                        lineWidth: 2, // in pixels\n                        barWidth: 1, // in units of the x axis\n                        fill: true,\n                        fillColor: null,\n                        align: \"left\", // \"left\", \"right\", or \"center\"\n                        horizontal: false,\n                        zero: true\n                    },\n                    shadowSize: 3,\n                    highlightColor: null\n                },\n                grid: {\n                    show: true,\n                    aboveData: false,\n                    color: \"#545454\", // primary color used for outline and labels\n                    backgroundColor: null, // null for transparent, else color\n                    borderColor: \"#eef0f2\", // set if different from the grid color\n                    tickColor: null, // color for the ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    margin: 0, // distance from the canvas edge to the grid\n                    labelMargin: 5, // in pixels\n                    axisMargin: 8, // in pixels\n                    borderWidth: 0, // in pixels\n                    minBorderMargin: null, // in pixels, null means taken from points radius\n                    markings: null, // array of ranges or fn: axes -> array of ranges\n                    markingsColor: \"#f4f4f4\",\n                    markingsLineWidth: 2,\n                    // interactive stuff\n                    clickable: false,\n                    hoverable: false,\n                    autoHighlight: true, // highlight in case mouse is near\n                    mouseActiveRadius: 10 // how far the mouse can be away to activate an item\n                },\n                interaction: {\n                    redrawOverlayInterval: 1000/60 // time between updates, -1 means in same flow\n                },\n                hooks: {}\n            },\n        surface = null,     // the canvas for the plot itself\n        overlay = null,     // canvas for interactive stuff on top of plot\n        eventHolder = null, // jQuery object that events should be bound to\n        ctx = null, octx = null,\n        xaxes = [], yaxes = [],\n        plotOffset = { left: 0, right: 0, top: 0, bottom: 0},\n        plotWidth = 0, plotHeight = 0,\n        hooks = {\n            processOptions: [],\n            processRawData: [],\n            processDatapoints: [],\n            processOffset: [],\n            drawBackground: [],\n            drawSeries: [],\n            draw: [],\n            bindEvents: [],\n            drawOverlay: [],\n            shutdown: []\n        },\n        plot = this;\n\n        // public functions\n        plot.setData = setData;\n        plot.setupGrid = setupGrid;\n        plot.draw = draw;\n        plot.getPlaceholder = function() { return placeholder; };\n        plot.getCanvas = function() { return surface.element; };\n        plot.getPlotOffset = function() { return plotOffset; };\n        plot.width = function () { return plotWidth; };\n        plot.height = function () { return plotHeight; };\n        plot.offset = function () {\n            var o = eventHolder.offset();\n            o.left += plotOffset.left;\n            o.top += plotOffset.top;\n            return o;\n        };\n        plot.getData = function () { return series; };\n        plot.getAxes = function () {\n            var res = {}, i;\n            $.each(xaxes.concat(yaxes), function (_, axis) {\n                if (axis)\n                    res[axis.direction + (axis.n != 1 ? axis.n : \"\") + \"axis\"] = axis;\n            });\n            return res;\n        };\n        plot.getXAxes = function () { return xaxes; };\n        plot.getYAxes = function () { return yaxes; };\n        plot.c2p = canvasToAxisCoords;\n        plot.p2c = axisToCanvasCoords;\n        plot.getOptions = function () { return options; };\n        plot.highlight = highlight;\n        plot.unhighlight = unhighlight;\n        plot.triggerRedrawOverlay = triggerRedrawOverlay;\n        plot.pointOffset = function(point) {\n            return {\n                left: parseInt(xaxes[axisNumber(point, \"x\") - 1].p2c(+point.x) + plotOffset.left, 10),\n                top: parseInt(yaxes[axisNumber(point, \"y\") - 1].p2c(+point.y) + plotOffset.top, 10)\n            };\n        };\n        plot.shutdown = shutdown;\n        plot.destroy = function () {\n            shutdown();\n            placeholder.removeData(\"plot\").empty();\n\n            series = [];\n            options = null;\n            surface = null;\n            overlay = null;\n            eventHolder = null;\n            ctx = null;\n            octx = null;\n            xaxes = [];\n            yaxes = [];\n            hooks = null;\n            highlights = [];\n            plot = null;\n        };\n        plot.resize = function () {\n        \tvar width = placeholder.width(),\n        \t\theight = placeholder.height();\n            surface.resize(width, height);\n            overlay.resize(width, height);\n        };\n\n        // public attributes\n        plot.hooks = hooks;\n\n        // initialize\n        initPlugins(plot);\n        parseOptions(options_);\n        setupCanvases();\n        setData(data_);\n        setupGrid();\n        draw();\n        bindEvents();\n\n\n        function executeHooks(hook, args) {\n            args = [plot].concat(args);\n            for (var i = 0; i < hook.length; ++i)\n                hook[i].apply(this, args);\n        }\n\n        function initPlugins() {\n\n            // References to key classes, allowing plugins to modify them\n\n            var classes = {\n                Canvas: Canvas\n            };\n\n            for (var i = 0; i < plugins.length; ++i) {\n                var p = plugins[i];\n                p.init(plot, classes);\n                if (p.options)\n                    $.extend(true, options, p.options);\n            }\n        }\n\n        function parseOptions(opts) {\n\n            $.extend(true, options, opts);\n\n            // $.extend merges arrays, rather than replacing them.  When less\n            // colors are provided than the size of the default palette, we\n            // end up with those colors plus the remaining defaults, which is\n            // not expected behavior; avoid it by replacing them here.\n\n            if (opts && opts.colors) {\n            \toptions.colors = opts.colors;\n            }\n\n            if (options.xaxis.color == null)\n                options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n            if (options.yaxis.color == null)\n                options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n\n            if (options.xaxis.tickColor == null) // grid.tickColor for back-compatibility\n                options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;\n            if (options.yaxis.tickColor == null) // grid.tickColor for back-compatibility\n                options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;\n\n            if (options.grid.borderColor == null)\n                options.grid.borderColor = options.grid.color;\n            if (options.grid.tickColor == null)\n                options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n\n            // Fill in defaults for axis options, including any unspecified\n            // font-spec fields, if a font-spec was provided.\n\n            // If no x/y axis options were provided, create one of each anyway,\n            // since the rest of the code assumes that they exist.\n\n            var i, axisOptions, axisCount,\n                fontSize = placeholder.css(\"font-size\"),\n                fontSizeDefault = fontSize ? +fontSize.replace(\"px\", \"\") : 13,\n                fontDefaults = {\n                    style: placeholder.css(\"font-style\"),\n                    size: Math.round(0.8 * fontSizeDefault),\n                    variant: placeholder.css(\"font-variant\"),\n                    weight: placeholder.css(\"font-weight\"),\n                    family: placeholder.css(\"font-family\")\n                };\n\n            axisCount = options.xaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n\n                axisOptions = options.xaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.xaxis, axisOptions);\n                options.xaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            axisCount = options.yaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n\n                axisOptions = options.yaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.yaxis, axisOptions);\n                options.yaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            // backwards compatibility, to be removed in future\n            if (options.xaxis.noTicks && options.xaxis.ticks == null)\n                options.xaxis.ticks = options.xaxis.noTicks;\n            if (options.yaxis.noTicks && options.yaxis.ticks == null)\n                options.yaxis.ticks = options.yaxis.noTicks;\n            if (options.x2axis) {\n                options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);\n                options.xaxes[1].position = \"top\";\n                // Override the inherit to allow the axis to auto-scale\n                if (options.x2axis.min == null) {\n                    options.xaxes[1].min = null;\n                }\n                if (options.x2axis.max == null) {\n                    options.xaxes[1].max = null;\n                }\n            }\n            if (options.y2axis) {\n                options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);\n                options.yaxes[1].position = \"right\";\n                // Override the inherit to allow the axis to auto-scale\n                if (options.y2axis.min == null) {\n                    options.yaxes[1].min = null;\n                }\n                if (options.y2axis.max == null) {\n                    options.yaxes[1].max = null;\n                }\n            }\n            if (options.grid.coloredAreas)\n                options.grid.markings = options.grid.coloredAreas;\n            if (options.grid.coloredAreasColor)\n                options.grid.markingsColor = options.grid.coloredAreasColor;\n            if (options.lines)\n                $.extend(true, options.series.lines, options.lines);\n            if (options.points)\n                $.extend(true, options.series.points, options.points);\n            if (options.bars)\n                $.extend(true, options.series.bars, options.bars);\n            if (options.shadowSize != null)\n                options.series.shadowSize = options.shadowSize;\n            if (options.highlightColor != null)\n                options.series.highlightColor = options.highlightColor;\n\n            // save options on axes for future reference\n            for (i = 0; i < options.xaxes.length; ++i)\n                getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];\n            for (i = 0; i < options.yaxes.length; ++i)\n                getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];\n\n            // add hooks from options\n            for (var n in hooks)\n                if (options.hooks[n] && options.hooks[n].length)\n                    hooks[n] = hooks[n].concat(options.hooks[n]);\n\n            executeHooks(hooks.processOptions, [options]);\n        }\n\n        function setData(d) {\n            series = parseData(d);\n            fillInSeriesOptions();\n            processData();\n        }\n\n        function parseData(d) {\n            var res = [];\n            for (var i = 0; i < d.length; ++i) {\n                var s = $.extend(true, {}, options.series);\n\n                if (d[i].data != null) {\n                    s.data = d[i].data; // move the data instead of deep-copy\n                    delete d[i].data;\n\n                    $.extend(true, s, d[i]);\n\n                    d[i].data = s.data;\n                }\n                else\n                    s.data = d[i];\n                res.push(s);\n            }\n\n            return res;\n        }\n\n        function axisNumber(obj, coord) {\n            var a = obj[coord + \"axis\"];\n            if (typeof a == \"object\") // if we got a real axis, extract number\n                a = a.n;\n            if (typeof a != \"number\")\n                a = 1; // default to first axis\n            return a;\n        }\n\n        function allAxes() {\n            // return flat array without annoying null entries\n            return $.grep(xaxes.concat(yaxes), function (a) { return a; });\n        }\n\n        function canvasToAxisCoords(pos) {\n            // return an object with x/y corresponding to all used axes\n            var res = {}, i, axis;\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used)\n                    res[\"x\" + axis.n] = axis.c2p(pos.left);\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used)\n                    res[\"y\" + axis.n] = axis.c2p(pos.top);\n            }\n\n            if (res.x1 !== undefined)\n                res.x = res.x1;\n            if (res.y1 !== undefined)\n                res.y = res.y1;\n\n            return res;\n        }\n\n        function axisToCanvasCoords(pos) {\n            // get canvas coords from the first pair of x/y found in pos\n            var res = {}, i, axis, key;\n\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used) {\n                    key = \"x\" + axis.n;\n                    if (pos[key] == null && axis.n == 1)\n                        key = \"x\";\n\n                    if (pos[key] != null) {\n                        res.left = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used) {\n                    key = \"y\" + axis.n;\n                    if (pos[key] == null && axis.n == 1)\n                        key = \"y\";\n\n                    if (pos[key] != null) {\n                        res.top = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        function getOrCreateAxis(axes, number) {\n            if (!axes[number - 1])\n                axes[number - 1] = {\n                    n: number, // save the number for future reference\n                    direction: axes == xaxes ? \"x\" : \"y\",\n                    options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)\n                };\n\n            return axes[number - 1];\n        }\n\n        function fillInSeriesOptions() {\n\n            var neededColors = series.length, maxIndex = -1, i;\n\n            // Subtract the number of series that already have fixed colors or\n            // color indexes from the number that we still need to generate.\n\n            for (i = 0; i < series.length; ++i) {\n                var sc = series[i].color;\n                if (sc != null) {\n                    neededColors--;\n                    if (typeof sc == \"number\" && sc > maxIndex) {\n                        maxIndex = sc;\n                    }\n                }\n            }\n\n            // If any of the series have fixed color indexes, then we need to\n            // generate at least as many colors as the highest index.\n\n            if (neededColors <= maxIndex) {\n                neededColors = maxIndex + 1;\n            }\n\n            // Generate all the colors, using first the option colors and then\n            // variations on those colors once they're exhausted.\n\n            var c, colors = [], colorPool = options.colors,\n                colorPoolSize = colorPool.length, variation = 0;\n\n            for (i = 0; i < neededColors; i++) {\n\n                c = $.color.parse(colorPool[i % colorPoolSize] || \"#666\");\n\n                // Each time we exhaust the colors in the pool we adjust\n                // a scaling factor used to produce more variations on\n                // those colors. The factor alternates negative/positive\n                // to produce lighter/darker colors.\n\n                // Reset the variation after every few cycles, or else\n                // it will end up producing only white or black colors.\n\n                if (i % colorPoolSize == 0 && i) {\n                    if (variation >= 0) {\n                        if (variation < 0.5) {\n                            variation = -variation - 0.2;\n                        } else variation = 0;\n                    } else variation = -variation;\n                }\n\n                colors[i] = c.scale('rgb', 1 + variation);\n            }\n\n            // Finalize the series options, filling in their colors\n\n            var colori = 0, s;\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                // assign colors\n                if (s.color == null) {\n                    s.color = colors[colori].toString();\n                    ++colori;\n                }\n                else if (typeof s.color == \"number\")\n                    s.color = colors[s.color].toString();\n\n                // turn on lines automatically in case nothing is set\n                if (s.lines.show == null) {\n                    var v, show = true;\n                    for (v in s)\n                        if (s[v] && s[v].show) {\n                            show = false;\n                            break;\n                        }\n                    if (show)\n                        s.lines.show = true;\n                }\n\n                // If nothing was provided for lines.zero, default it to match\n                // lines.fill, since areas by default should extend to zero.\n\n                if (s.lines.zero == null) {\n                    s.lines.zero = !!s.lines.fill;\n                }\n\n                // setup axes\n                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, \"x\"));\n                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, \"y\"));\n            }\n        }\n\n        function processData() {\n            var topSentry = Number.POSITIVE_INFINITY,\n                bottomSentry = Number.NEGATIVE_INFINITY,\n                fakeInfinity = Number.MAX_VALUE,\n                i, j, k, m, length,\n                s, points, ps, x, y, axis, val, f, p,\n                data, format;\n\n            function updateAxis(axis, min, max) {\n                if (min < axis.datamin && min != -fakeInfinity)\n                    axis.datamin = min;\n                if (max > axis.datamax && max != fakeInfinity)\n                    axis.datamax = max;\n            }\n\n            $.each(allAxes(), function (_, axis) {\n                // init axis\n                axis.datamin = topSentry;\n                axis.datamax = bottomSentry;\n                axis.used = false;\n            });\n\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                s.datapoints = { points: [] };\n\n                executeHooks(hooks.processRawData, [ s, s.data, s.datapoints ]);\n            }\n\n            // first pass: clean and copy data\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                data = s.data;\n                format = s.datapoints.format;\n\n                if (!format) {\n                    format = [];\n                    // find out how to copy\n                    format.push({ x: true, number: true, required: true });\n                    format.push({ y: true, number: true, required: true });\n\n                    if (s.bars.show || (s.lines.show && s.lines.fill)) {\n                        var autoscale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));\n                        format.push({ y: true, number: true, required: false, defaultValue: 0, autoscale: autoscale });\n                        if (s.bars.horizontal) {\n                            delete format[format.length - 1].y;\n                            format[format.length - 1].x = true;\n                        }\n                    }\n\n                    s.datapoints.format = format;\n                }\n\n                if (s.datapoints.pointsize != null)\n                    continue; // already filled in\n\n                s.datapoints.pointsize = format.length;\n\n                ps = s.datapoints.pointsize;\n                points = s.datapoints.points;\n\n                var insertSteps = s.lines.show && s.lines.steps;\n                s.xaxis.used = s.yaxis.used = true;\n\n                for (j = k = 0; j < data.length; ++j, k += ps) {\n                    p = data[j];\n\n                    var nullify = p == null;\n                    if (!nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = p[m];\n                            f = format[m];\n\n                            if (f) {\n                                if (f.number && val != null) {\n                                    val = +val; // convert to number\n                                    if (isNaN(val))\n                                        val = null;\n                                    else if (val == Infinity)\n                                        val = fakeInfinity;\n                                    else if (val == -Infinity)\n                                        val = -fakeInfinity;\n                                }\n\n                                if (val == null) {\n                                    if (f.required)\n                                        nullify = true;\n\n                                    if (f.defaultValue != null)\n                                        val = f.defaultValue;\n                                }\n                            }\n\n                            points[k + m] = val;\n                        }\n                    }\n\n                    if (nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = points[k + m];\n                            if (val != null) {\n                                f = format[m];\n                                // extract min/max info\n                                if (f.autoscale !== false) {\n                                    if (f.x) {\n                                        updateAxis(s.xaxis, val, val);\n                                    }\n                                    if (f.y) {\n                                        updateAxis(s.yaxis, val, val);\n                                    }\n                                }\n                            }\n                            points[k + m] = null;\n                        }\n                    }\n                    else {\n                        // a little bit of line specific stuff that\n                        // perhaps shouldn't be here, but lacking\n                        // better means...\n                        if (insertSteps && k > 0\n                            && points[k - ps] != null\n                            && points[k - ps] != points[k]\n                            && points[k - ps + 1] != points[k + 1]) {\n                            // copy the point to make room for a middle point\n                            for (m = 0; m < ps; ++m)\n                                points[k + ps + m] = points[k + m];\n\n                            // middle point has same y\n                            points[k + 1] = points[k - ps + 1];\n\n                            // we've added a point, better reflect that\n                            k += ps;\n                        }\n                    }\n                }\n            }\n\n            // give the hooks a chance to run\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                executeHooks(hooks.processDatapoints, [ s, s.datapoints]);\n            }\n\n            // second pass: find datamax/datamin for auto-scaling\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                points = s.datapoints.points;\n                ps = s.datapoints.pointsize;\n                format = s.datapoints.format;\n\n                var xmin = topSentry, ymin = topSentry,\n                    xmax = bottomSentry, ymax = bottomSentry;\n\n                for (j = 0; j < points.length; j += ps) {\n                    if (points[j] == null)\n                        continue;\n\n                    for (m = 0; m < ps; ++m) {\n                        val = points[j + m];\n                        f = format[m];\n                        if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity)\n                            continue;\n\n                        if (f.x) {\n                            if (val < xmin)\n                                xmin = val;\n                            if (val > xmax)\n                                xmax = val;\n                        }\n                        if (f.y) {\n                            if (val < ymin)\n                                ymin = val;\n                            if (val > ymax)\n                                ymax = val;\n                        }\n                    }\n                }\n\n                if (s.bars.show) {\n                    // make sure we got room for the bar on the dancing floor\n                    var delta;\n\n                    switch (s.bars.align) {\n                        case \"left\":\n                            delta = 0;\n                            break;\n                        case \"right\":\n                            delta = -s.bars.barWidth;\n                            break;\n                        default:\n                            delta = -s.bars.barWidth / 2;\n                    }\n\n                    if (s.bars.horizontal) {\n                        ymin += delta;\n                        ymax += delta + s.bars.barWidth;\n                    }\n                    else {\n                        xmin += delta;\n                        xmax += delta + s.bars.barWidth;\n                    }\n                }\n\n                updateAxis(s.xaxis, xmin, xmax);\n                updateAxis(s.yaxis, ymin, ymax);\n            }\n\n            $.each(allAxes(), function (_, axis) {\n                if (axis.datamin == topSentry)\n                    axis.datamin = null;\n                if (axis.datamax == bottomSentry)\n                    axis.datamax = null;\n            });\n        }\n\n        function setupCanvases() {\n\n            // Make sure the placeholder is clear of everything except canvases\n            // from a previous plot in this container that we'll try to re-use.\n\n            placeholder.css(\"padding\", 0) // padding messes up the positioning\n                .children().filter(function(){\n                    return !$(this).hasClass(\"flot-overlay\") && !$(this).hasClass('flot-base');\n                }).remove();\n\n            if (placeholder.css(\"position\") == 'static')\n                placeholder.css(\"position\", \"relative\"); // for positioning labels and overlay\n\n            surface = new Canvas(\"flot-base\", placeholder);\n            overlay = new Canvas(\"flot-overlay\", placeholder); // overlay canvas for interactive features\n\n            ctx = surface.context;\n            octx = overlay.context;\n\n            // define which element we're listening for events on\n            eventHolder = $(overlay.element).unbind();\n\n            // If we're re-using a plot object, shut down the old one\n\n            var existing = placeholder.data(\"plot\");\n\n            if (existing) {\n                existing.shutdown();\n                overlay.clear();\n            }\n\n            // save in case we get replotted\n            placeholder.data(\"plot\", plot);\n        }\n\n        function bindEvents() {\n            // bind events\n            if (options.grid.hoverable) {\n                eventHolder.mousemove(onMouseMove);\n\n                // Use bind, rather than .mouseleave, because we officially\n                // still support jQuery 1.2.6, which doesn't define a shortcut\n                // for mouseenter or mouseleave.  This was a bug/oversight that\n                // was fixed somewhere around 1.3.x.  We can return to using\n                // .mouseleave when we drop support for 1.2.6.\n\n                eventHolder.bind(\"mouseleave\", onMouseLeave);\n            }\n\n            if (options.grid.clickable)\n                eventHolder.click(onClick);\n\n            executeHooks(hooks.bindEvents, [eventHolder]);\n        }\n\n        function shutdown() {\n            if (redrawTimeout)\n                clearTimeout(redrawTimeout);\n\n            eventHolder.unbind(\"mousemove\", onMouseMove);\n            eventHolder.unbind(\"mouseleave\", onMouseLeave);\n            eventHolder.unbind(\"click\", onClick);\n\n            executeHooks(hooks.shutdown, [eventHolder]);\n        }\n\n        function setTransformationHelpers(axis) {\n            // set helper functions on the axis, assumes plot area\n            // has been computed already\n\n            function identity(x) { return x; }\n\n            var s, m, t = axis.options.transform || identity,\n                it = axis.options.inverseTransform;\n\n            // precompute how much the axis is scaling a point\n            // in canvas space\n            if (axis.direction == \"x\") {\n                s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));\n                m = Math.min(t(axis.max), t(axis.min));\n            }\n            else {\n                s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));\n                s = -s;\n                m = Math.max(t(axis.max), t(axis.min));\n            }\n\n            // data point to canvas coordinate\n            if (t == identity) // slight optimization\n                axis.p2c = function (p) { return (p - m) * s; };\n            else\n                axis.p2c = function (p) { return (t(p) - m) * s; };\n            // canvas coordinate to data point\n            if (!it)\n                axis.c2p = function (c) { return m + c / s; };\n            else\n                axis.c2p = function (c) { return it(m + c / s); };\n        }\n\n        function measureTickLabels(axis) {\n\n            var opts = axis.options,\n                ticks = axis.ticks || [],\n                labelWidth = opts.labelWidth || 0,\n                labelHeight = opts.labelHeight || 0,\n                maxWidth = labelWidth || (axis.direction == \"x\" ? Math.floor(surface.width / (ticks.length || 1)) : null),\n                legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                font = opts.font || \"flot-tick-label tickLabel\";\n\n            for (var i = 0; i < ticks.length; ++i) {\n\n                var t = ticks[i];\n\n                if (!t.label)\n                    continue;\n\n                var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);\n\n                labelWidth = Math.max(labelWidth, info.width);\n                labelHeight = Math.max(labelHeight, info.height);\n            }\n\n            axis.labelWidth = opts.labelWidth || labelWidth;\n            axis.labelHeight = opts.labelHeight || labelHeight;\n        }\n\n        function allocateAxisBoxFirstPhase(axis) {\n            // find the bounding box of the axis by looking at label\n            // widths/heights and ticks, make room by diminishing the\n            // plotOffset; this first phase only looks at one\n            // dimension per axis, the other dimension depends on the\n            // other axes so will have to wait\n\n            var lw = axis.labelWidth,\n                lh = axis.labelHeight,\n                pos = axis.options.position,\n                isXAxis = axis.direction === \"x\",\n                tickLength = axis.options.tickLength,\n                axisMargin = options.grid.axisMargin,\n                padding = options.grid.labelMargin,\n                innermost = true,\n                outermost = true,\n                first = true,\n                found = false;\n\n            // Determine the axis's position in its direction and on its side\n\n            $.each(isXAxis ? xaxes : yaxes, function(i, a) {\n                if (a && (a.show || a.reserveSpace)) {\n                    if (a === axis) {\n                        found = true;\n                    } else if (a.options.position === pos) {\n                        if (found) {\n                            outermost = false;\n                        } else {\n                            innermost = false;\n                        }\n                    }\n                    if (!found) {\n                        first = false;\n                    }\n                }\n            });\n\n            // The outermost axis on each side has no margin\n\n            if (outermost) {\n                axisMargin = 0;\n            }\n\n            // The ticks for the first axis in each direction stretch across\n\n            if (tickLength == null) {\n                tickLength = first ? \"full\" : 5;\n            }\n\n            if (!isNaN(+tickLength))\n                padding += +tickLength;\n\n            if (isXAxis) {\n                lh += padding;\n\n                if (pos == \"bottom\") {\n                    plotOffset.bottom += lh + axisMargin;\n                    axis.box = { top: surface.height - plotOffset.bottom, height: lh };\n                }\n                else {\n                    axis.box = { top: plotOffset.top + axisMargin, height: lh };\n                    plotOffset.top += lh + axisMargin;\n                }\n            }\n            else {\n                lw += padding;\n\n                if (pos == \"left\") {\n                    axis.box = { left: plotOffset.left + axisMargin, width: lw };\n                    plotOffset.left += lw + axisMargin;\n                }\n                else {\n                    plotOffset.right += lw + axisMargin;\n                    axis.box = { left: surface.width - plotOffset.right, width: lw };\n                }\n            }\n\n             // save for future reference\n            axis.position = pos;\n            axis.tickLength = tickLength;\n            axis.box.padding = padding;\n            axis.innermost = innermost;\n        }\n\n        function allocateAxisBoxSecondPhase(axis) {\n            // now that all axis boxes have been placed in one\n            // dimension, we can set the remaining dimension coordinates\n            if (axis.direction == \"x\") {\n                axis.box.left = plotOffset.left - axis.labelWidth / 2;\n                axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;\n            }\n            else {\n                axis.box.top = plotOffset.top - axis.labelHeight / 2;\n                axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;\n            }\n        }\n\n        function adjustLayoutForThingsStickingOut() {\n            // possibly adjust plot offset to ensure everything stays\n            // inside the canvas and isn't clipped off\n\n            var minMargin = options.grid.minBorderMargin,\n                axis, i;\n\n            // check stuff from the plot (FIXME: this should just read\n            // a value from the series, otherwise it's impossible to\n            // customize)\n            if (minMargin == null) {\n                minMargin = 0;\n                for (i = 0; i < series.length; ++i)\n                    minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth/2));\n            }\n\n            var margins = {\n                left: minMargin,\n                right: minMargin,\n                top: minMargin,\n                bottom: minMargin\n            };\n\n            // check axis labels, note we don't check the actual\n            // labels but instead use the overall width/height to not\n            // jump as much around with replots\n            $.each(allAxes(), function (_, axis) {\n                if (axis.reserveSpace && axis.ticks && axis.ticks.length) {\n                    if (axis.direction === \"x\") {\n                        margins.left = Math.max(margins.left, axis.labelWidth / 2);\n                        margins.right = Math.max(margins.right, axis.labelWidth / 2);\n                    } else {\n                        margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);\n                        margins.top = Math.max(margins.top, axis.labelHeight / 2);\n                    }\n                }\n            });\n\n            plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));\n            plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));\n            plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));\n            plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));\n        }\n\n        function setupGrid() {\n            var i, axes = allAxes(), showGrid = options.grid.show;\n\n            // Initialize the plot's offset from the edge of the canvas\n\n            for (var a in plotOffset) {\n                var margin = options.grid.margin || 0;\n                plotOffset[a] = typeof margin == \"number\" ? margin : margin[a] || 0;\n            }\n\n            executeHooks(hooks.processOffset, [plotOffset]);\n\n            // If the grid is visible, add its border width to the offset\n\n            for (var a in plotOffset) {\n                if(typeof(options.grid.borderWidth) == \"object\") {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;\n                }\n                else {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth : 0;\n                }\n            }\n\n            $.each(axes, function (_, axis) {\n                var axisOpts = axis.options;\n                axis.show = axisOpts.show == null ? axis.used : axisOpts.show;\n                axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;\n                setRange(axis);\n            });\n\n            if (showGrid) {\n\n                var allocatedAxes = $.grep(axes, function (axis) {\n                    return axis.show || axis.reserveSpace;\n                });\n\n                $.each(allocatedAxes, function (_, axis) {\n                    // make the ticks\n                    setupTickGeneration(axis);\n                    setTicks(axis);\n                    snapRangeToTicks(axis, axis.ticks);\n                    // find labelWidth/Height for axis\n                    measureTickLabels(axis);\n                });\n\n                // with all dimensions calculated, we can compute the\n                // axis bounding boxes, start from the outside\n                // (reverse order)\n                for (i = allocatedAxes.length - 1; i >= 0; --i)\n                    allocateAxisBoxFirstPhase(allocatedAxes[i]);\n\n                // make sure we've got enough space for things that\n                // might stick out\n                adjustLayoutForThingsStickingOut();\n\n                $.each(allocatedAxes, function (_, axis) {\n                    allocateAxisBoxSecondPhase(axis);\n                });\n            }\n\n            plotWidth = surface.width - plotOffset.left - plotOffset.right;\n            plotHeight = surface.height - plotOffset.bottom - plotOffset.top;\n\n            // now we got the proper plot dimensions, we can compute the scaling\n            $.each(axes, function (_, axis) {\n                setTransformationHelpers(axis);\n            });\n\n            if (showGrid) {\n                drawAxisLabels();\n            }\n\n            insertLegend();\n        }\n\n        function setRange(axis) {\n            var opts = axis.options,\n                min = +(opts.min != null ? opts.min : axis.datamin),\n                max = +(opts.max != null ? opts.max : axis.datamax),\n                delta = max - min;\n\n            if (delta == 0.0) {\n                // degenerate case\n                var widen = max == 0 ? 1 : 0.01;\n\n                if (opts.min == null)\n                    min -= widen;\n                // always widen max if we couldn't widen min to ensure we\n                // don't fall into min == max which doesn't work\n                if (opts.max == null || opts.min != null)\n                    max += widen;\n            }\n            else {\n                // consider autoscaling\n                var margin = opts.autoscaleMargin;\n                if (margin != null) {\n                    if (opts.min == null) {\n                        min -= delta * margin;\n                        // make sure we don't go below zero if all values\n                        // are positive\n                        if (min < 0 && axis.datamin != null && axis.datamin >= 0)\n                            min = 0;\n                    }\n                    if (opts.max == null) {\n                        max += delta * margin;\n                        if (max > 0 && axis.datamax != null && axis.datamax <= 0)\n                            max = 0;\n                    }\n                }\n            }\n            axis.min = min;\n            axis.max = max;\n        }\n\n        function setupTickGeneration(axis) {\n            var opts = axis.options;\n\n            // estimate number of ticks\n            var noTicks;\n            if (typeof opts.ticks == \"number\" && opts.ticks > 0)\n                noTicks = opts.ticks;\n            else\n                // heuristic based on the model a*sqrt(x) fitted to\n                // some data points that seemed reasonable\n                noTicks = 0.3 * Math.sqrt(axis.direction == \"x\" ? surface.width : surface.height);\n\n            var delta = (axis.max - axis.min) / noTicks,\n                dec = -Math.floor(Math.log(delta) / Math.LN10),\n                maxDec = opts.tickDecimals;\n\n            if (maxDec != null && dec > maxDec) {\n                dec = maxDec;\n            }\n\n            var magn = Math.pow(10, -dec),\n                norm = delta / magn, // norm is between 1.0 and 10.0\n                size;\n\n            if (norm < 1.5) {\n                size = 1;\n            } else if (norm < 3) {\n                size = 2;\n                // special case for 2.5, requires an extra decimal\n                if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {\n                    size = 2.5;\n                    ++dec;\n                }\n            } else if (norm < 7.5) {\n                size = 5;\n            } else {\n                size = 10;\n            }\n\n            size *= magn;\n\n            if (opts.minTickSize != null && size < opts.minTickSize) {\n                size = opts.minTickSize;\n            }\n\n            axis.delta = delta;\n            axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);\n            axis.tickSize = opts.tickSize || size;\n\n            // Time mode was moved to a plug-in in 0.8, and since so many people use it\n            // we'll add an especially friendly reminder to make sure they included it.\n\n            if (opts.mode == \"time\" && !axis.tickGenerator) {\n                throw new Error(\"Time mode requires the flot.time plugin.\");\n            }\n\n            // Flot supports base-10 axes; any other mode else is handled by a plug-in,\n            // like flot.time.js.\n\n            if (!axis.tickGenerator) {\n\n                axis.tickGenerator = function (axis) {\n\n                    var ticks = [],\n                        start = floorInBase(axis.min, axis.tickSize),\n                        i = 0,\n                        v = Number.NaN,\n                        prev;\n\n                    do {\n                        prev = v;\n                        v = start + i * axis.tickSize;\n                        ticks.push(v);\n                        ++i;\n                    } while (v < axis.max && v != prev);\n                    return ticks;\n                };\n\n\t\t\t\taxis.tickFormatter = function (value, axis) {\n\n\t\t\t\t\tvar factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;\n\t\t\t\t\tvar formatted = \"\" + Math.round(value * factor) / factor;\n\n\t\t\t\t\t// If tickDecimals was specified, ensure that we have exactly that\n\t\t\t\t\t// much precision; otherwise default to the value's own precision.\n\n\t\t\t\t\tif (axis.tickDecimals != null) {\n\t\t\t\t\t\tvar decimal = formatted.indexOf(\".\");\n\t\t\t\t\t\tvar precision = decimal == -1 ? 0 : formatted.length - decimal - 1;\n\t\t\t\t\t\tif (precision < axis.tickDecimals) {\n\t\t\t\t\t\t\treturn (precision ? formatted : formatted + \".\") + (\"\" + factor).substr(1, axis.tickDecimals - precision);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n                    return formatted;\n                };\n            }\n\n            if ($.isFunction(opts.tickFormatter))\n                axis.tickFormatter = function (v, axis) { return \"\" + opts.tickFormatter(v, axis); };\n\n            if (opts.alignTicksWithAxis != null) {\n                var otherAxis = (axis.direction == \"x\" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];\n                if (otherAxis && otherAxis.used && otherAxis != axis) {\n                    // consider snapping min/max to outermost nice ticks\n                    var niceTicks = axis.tickGenerator(axis);\n                    if (niceTicks.length > 0) {\n                        if (opts.min == null)\n                            axis.min = Math.min(axis.min, niceTicks[0]);\n                        if (opts.max == null && niceTicks.length > 1)\n                            axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);\n                    }\n\n                    axis.tickGenerator = function (axis) {\n                        // copy ticks, scaled to this axis\n                        var ticks = [], v, i;\n                        for (i = 0; i < otherAxis.ticks.length; ++i) {\n                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);\n                            v = axis.min + v * (axis.max - axis.min);\n                            ticks.push(v);\n                        }\n                        return ticks;\n                    };\n\n                    // we might need an extra decimal since forced\n                    // ticks don't necessarily fit naturally\n                    if (!axis.mode && opts.tickDecimals == null) {\n                        var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),\n                            ts = axis.tickGenerator(axis);\n\n                        // only proceed if the tick interval rounded\n                        // with an extra decimal doesn't give us a\n                        // zero at end\n                        if (!(ts.length > 1 && /\\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec))))\n                            axis.tickDecimals = extraDec;\n                    }\n                }\n            }\n        }\n\n        function setTicks(axis) {\n            var oticks = axis.options.ticks, ticks = [];\n            if (oticks == null || (typeof oticks == \"number\" && oticks > 0))\n                ticks = axis.tickGenerator(axis);\n            else if (oticks) {\n                if ($.isFunction(oticks))\n                    // generate the ticks\n                    ticks = oticks(axis);\n                else\n                    ticks = oticks;\n            }\n\n            // clean up/labelify the supplied ticks, copy them over\n            var i, v;\n            axis.ticks = [];\n            for (i = 0; i < ticks.length; ++i) {\n                var label = null;\n                var t = ticks[i];\n                if (typeof t == \"object\") {\n                    v = +t[0];\n                    if (t.length > 1)\n                        label = t[1];\n                }\n                else\n                    v = +t;\n                if (label == null)\n                    label = axis.tickFormatter(v, axis);\n                if (!isNaN(v))\n                    axis.ticks.push({ v: v, label: label });\n            }\n        }\n\n        function snapRangeToTicks(axis, ticks) {\n            if (axis.options.autoscaleMargin && ticks.length > 0) {\n                // snap to ticks\n                if (axis.options.min == null)\n                    axis.min = Math.min(axis.min, ticks[0].v);\n                if (axis.options.max == null && ticks.length > 1)\n                    axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);\n            }\n        }\n\n        function draw() {\n\n            surface.clear();\n\n            executeHooks(hooks.drawBackground, [ctx]);\n\n            var grid = options.grid;\n\n            // draw background, if any\n            if (grid.show && grid.backgroundColor)\n                drawBackground();\n\n            if (grid.show && !grid.aboveData) {\n                drawGrid();\n            }\n\n            for (var i = 0; i < series.length; ++i) {\n                executeHooks(hooks.drawSeries, [ctx, series[i]]);\n                drawSeries(series[i]);\n            }\n\n            executeHooks(hooks.draw, [ctx]);\n\n            if (grid.show && grid.aboveData) {\n                drawGrid();\n            }\n\n            surface.render();\n\n            // A draw implies that either the axes or data have changed, so we\n            // should probably update the overlay highlights as well.\n\n            triggerRedrawOverlay();\n        }\n\n        function extractRange(ranges, coord) {\n            var axis, from, to, key, axes = allAxes();\n\n            for (var i = 0; i < axes.length; ++i) {\n                axis = axes[i];\n                if (axis.direction == coord) {\n                    key = coord + axis.n + \"axis\";\n                    if (!ranges[key] && axis.n == 1)\n                        key = coord + \"axis\"; // support x1axis as xaxis\n                    if (ranges[key]) {\n                        from = ranges[key].from;\n                        to = ranges[key].to;\n                        break;\n                    }\n                }\n            }\n\n            // backwards-compat stuff - to be removed in future\n            if (!ranges[key]) {\n                axis = coord == \"x\" ? xaxes[0] : yaxes[0];\n                from = ranges[coord + \"1\"];\n                to = ranges[coord + \"2\"];\n            }\n\n            // auto-reverse as an added bonus\n            if (from != null && to != null && from > to) {\n                var tmp = from;\n                from = to;\n                to = tmp;\n            }\n\n            return { from: from, to: to, axis: axis };\n        }\n\n        function drawBackground() {\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, \"rgba(255, 255, 255, 0)\");\n            ctx.fillRect(0, 0, plotWidth, plotHeight);\n            ctx.restore();\n        }\n\n        function drawGrid() {\n            var i, axes, bw, bc;\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            // draw markings\n            var markings = options.grid.markings;\n            if (markings) {\n                if ($.isFunction(markings)) {\n                    axes = plot.getAxes();\n                    // xmin etc. is backwards compatibility, to be\n                    // removed in the future\n                    axes.xmin = axes.xaxis.min;\n                    axes.xmax = axes.xaxis.max;\n                    axes.ymin = axes.yaxis.min;\n                    axes.ymax = axes.yaxis.max;\n\n                    markings = markings(axes);\n                }\n\n                for (i = 0; i < markings.length; ++i) {\n                    var m = markings[i],\n                        xrange = extractRange(m, \"x\"),\n                        yrange = extractRange(m, \"y\");\n\n                    // fill in missing\n                    if (xrange.from == null)\n                        xrange.from = xrange.axis.min;\n                    if (xrange.to == null)\n                        xrange.to = xrange.axis.max;\n                    if (yrange.from == null)\n                        yrange.from = yrange.axis.min;\n                    if (yrange.to == null)\n                        yrange.to = yrange.axis.max;\n\n                    // clip\n                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||\n                        yrange.to < yrange.axis.min || yrange.from > yrange.axis.max)\n                        continue;\n\n                    xrange.from = Math.max(xrange.from, xrange.axis.min);\n                    xrange.to = Math.min(xrange.to, xrange.axis.max);\n                    yrange.from = Math.max(yrange.from, yrange.axis.min);\n                    yrange.to = Math.min(yrange.to, yrange.axis.max);\n\n                    var xequal = xrange.from === xrange.to,\n                        yequal = yrange.from === yrange.to;\n\n                    if (xequal && yequal) {\n                        continue;\n                    }\n\n                    // then draw\n                    xrange.from = Math.floor(xrange.axis.p2c(xrange.from));\n                    xrange.to = Math.floor(xrange.axis.p2c(xrange.to));\n                    yrange.from = Math.floor(yrange.axis.p2c(yrange.from));\n                    yrange.to = Math.floor(yrange.axis.p2c(yrange.to));\n\n                    if (xequal || yequal) {\n                        var lineWidth = m.lineWidth || options.grid.markingsLineWidth,\n                            subPixel = lineWidth % 2 ? 0.5 : 0;\n                        ctx.beginPath();\n                        ctx.strokeStyle = m.color || options.grid.markingsColor;\n                        ctx.lineWidth = lineWidth;\n                        if (xequal) {\n                            ctx.moveTo(xrange.to + subPixel, yrange.from);\n                            ctx.lineTo(xrange.to + subPixel, yrange.to);\n                        } else {\n                            ctx.moveTo(xrange.from, yrange.to + subPixel);\n                            ctx.lineTo(xrange.to, yrange.to + subPixel);\n                        }\n                        ctx.stroke();\n                    } else {\n                        ctx.fillStyle = m.color || options.grid.markingsColor;\n                        ctx.fillRect(xrange.from, yrange.to,\n                                     xrange.to - xrange.from,\n                                     yrange.from - yrange.to);\n                    }\n                }\n            }\n\n            // draw the ticks\n            axes = allAxes();\n            bw = options.grid.borderWidth;\n\n            for (var j = 0; j < axes.length; ++j) {\n                var axis = axes[j], box = axis.box,\n                    t = axis.tickLength, x, y, xoff, yoff;\n                if (!axis.show || axis.ticks.length == 0)\n                    continue;\n\n                ctx.lineWidth = 1;\n\n                // find the edges\n                if (axis.direction == \"x\") {\n                    x = 0;\n                    if (t == \"full\")\n                        y = (axis.position == \"top\" ? 0 : plotHeight);\n                    else\n                        y = box.top - plotOffset.top + (axis.position == \"top\" ? box.height : 0);\n                }\n                else {\n                    y = 0;\n                    if (t == \"full\")\n                        x = (axis.position == \"left\" ? 0 : plotWidth);\n                    else\n                        x = box.left - plotOffset.left + (axis.position == \"left\" ? box.width : 0);\n                }\n\n                // draw tick bar\n                if (!axis.innermost) {\n                    ctx.strokeStyle = axis.options.color;\n                    ctx.beginPath();\n                    xoff = yoff = 0;\n                    if (axis.direction == \"x\")\n                        xoff = plotWidth + 1;\n                    else\n                        yoff = plotHeight + 1;\n\n                    if (ctx.lineWidth == 1) {\n                        if (axis.direction == \"x\") {\n                            y = Math.floor(y) + 0.5;\n                        } else {\n                            x = Math.floor(x) + 0.5;\n                        }\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                    ctx.stroke();\n                }\n\n                // draw ticks\n\n                ctx.strokeStyle = axis.options.tickColor;\n\n                ctx.beginPath();\n                for (i = 0; i < axis.ticks.length; ++i) {\n                    var v = axis.ticks[i].v;\n\n                    xoff = yoff = 0;\n\n                    if (isNaN(v) || v < axis.min || v > axis.max\n                        // skip those lying on the axes if we got a border\n                        || (t == \"full\"\n                            && ((typeof bw == \"object\" && bw[axis.position] > 0) || bw > 0)\n                            && (v == axis.min || v == axis.max)))\n                        continue;\n\n                    if (axis.direction == \"x\") {\n                        x = axis.p2c(v);\n                        yoff = t == \"full\" ? -plotHeight : t;\n\n                        if (axis.position == \"top\")\n                            yoff = -yoff;\n                    }\n                    else {\n                        y = axis.p2c(v);\n                        xoff = t == \"full\" ? -plotWidth : t;\n\n                        if (axis.position == \"left\")\n                            xoff = -xoff;\n                    }\n\n                    if (ctx.lineWidth == 1) {\n                        if (axis.direction == \"x\")\n                            x = Math.floor(x) + 0.5;\n                        else\n                            y = Math.floor(y) + 0.5;\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                }\n\n                ctx.stroke();\n            }\n\n\n            // draw border\n            if (bw) {\n                // If either borderWidth or borderColor is an object, then draw the border\n                // line by line instead of as one rectangle\n                bc = options.grid.borderColor;\n                if(typeof bw == \"object\" || typeof bc == \"object\") {\n                    if (typeof bw !== \"object\") {\n                        bw = {top: bw, right: bw, bottom: bw, left: bw};\n                    }\n                    if (typeof bc !== \"object\") {\n                        bc = {top: bc, right: bc, bottom: bc, left: bc};\n                    }\n\n                    if (bw.top > 0) {\n                        ctx.strokeStyle = bc.top;\n                        ctx.lineWidth = bw.top;\n                        ctx.beginPath();\n                        ctx.moveTo(0 - bw.left, 0 - bw.top/2);\n                        ctx.lineTo(plotWidth, 0 - bw.top/2);\n                        ctx.stroke();\n                    }\n\n                    if (bw.right > 0) {\n                        ctx.strokeStyle = bc.right;\n                        ctx.lineWidth = bw.right;\n                        ctx.beginPath();\n                        ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);\n                        ctx.lineTo(plotWidth + bw.right / 2, plotHeight);\n                        ctx.stroke();\n                    }\n\n                    if (bw.bottom > 0) {\n                        ctx.strokeStyle = bc.bottom;\n                        ctx.lineWidth = bw.bottom;\n                        ctx.beginPath();\n                        ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);\n                        ctx.lineTo(0, plotHeight + bw.bottom / 2);\n                        ctx.stroke();\n                    }\n\n                    if (bw.left > 0) {\n                        ctx.strokeStyle = bc.left;\n                        ctx.lineWidth = bw.left;\n                        ctx.beginPath();\n                        ctx.moveTo(0 - bw.left/2, plotHeight + bw.bottom);\n                        ctx.lineTo(0- bw.left/2, 0);\n                        ctx.stroke();\n                    }\n                }\n                else {\n                    ctx.lineWidth = bw;\n                    ctx.strokeStyle = options.grid.borderColor;\n                    ctx.strokeRect(-bw/2, -bw/2, plotWidth + bw, plotHeight + bw);\n                }\n            }\n\n            ctx.restore();\n        }\n\n        function drawAxisLabels() {\n\n            $.each(allAxes(), function (_, axis) {\n                var box = axis.box,\n                    legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                    layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                    font = axis.options.font || \"flot-tick-label tickLabel\",\n                    tick, x, y, halign, valign;\n\n                // Remove text before checking for axis.show and ticks.length;\n                // otherwise plugins, like flot-tickrotor, that draw their own\n                // tick labels will end up with both theirs and the defaults.\n\n                surface.removeText(layer);\n\n                if (!axis.show || axis.ticks.length == 0)\n                    return;\n\n                for (var i = 0; i < axis.ticks.length; ++i) {\n\n                    tick = axis.ticks[i];\n                    if (!tick.label || tick.v < axis.min || tick.v > axis.max)\n                        continue;\n\n                    if (axis.direction == \"x\") {\n                        halign = \"center\";\n                        x = plotOffset.left + axis.p2c(tick.v);\n                        if (axis.position == \"bottom\") {\n                            y = box.top + box.padding;\n                        } else {\n                            y = box.top + box.height - box.padding;\n                            valign = \"bottom\";\n                        }\n                    } else {\n                        valign = \"middle\";\n                        y = plotOffset.top + axis.p2c(tick.v);\n                        if (axis.position == \"left\") {\n                            x = box.left + box.width - box.padding;\n                            halign = \"right\";\n                        } else {\n                            x = box.left + box.padding;\n                        }\n                    }\n\n                    surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);\n                }\n            });\n        }\n\n        function drawSeries(series) {\n            if (series.lines.show)\n                drawSeriesLines(series);\n            if (series.bars.show)\n                drawSeriesBars(series);\n            if (series.points.show)\n                drawSeriesPoints(series);\n        }\n\n        function drawSeriesLines(series) {\n            function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    prevx = null, prevy = null;\n\n                ctx.beginPath();\n                for (var i = ps; i < points.length; i += ps) {\n                    var x1 = points[i - ps], y1 = points[i - ps + 1],\n                        x2 = points[i], y2 = points[i + 1];\n\n                    if (x1 == null || x2 == null)\n                        continue;\n\n                    // clip with ymin\n                    if (y1 <= y2 && y1 < axisy.min) {\n                        if (y2 < axisy.min)\n                            continue;   // line segment is outside\n                        // compute new intersection point\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.min;\n                    }\n                    else if (y2 <= y1 && y2 < axisy.min) {\n                        if (y1 < axisy.min)\n                            continue;\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.min;\n                    }\n\n                    // clip with ymax\n                    if (y1 >= y2 && y1 > axisy.max) {\n                        if (y2 > axisy.max)\n                            continue;\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.max;\n                    }\n                    else if (y2 >= y1 && y2 > axisy.max) {\n                        if (y1 > axisy.max)\n                            continue;\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.max;\n                    }\n\n                    // clip with xmin\n                    if (x1 <= x2 && x1 < axisx.min) {\n                        if (x2 < axisx.min)\n                            continue;\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.min;\n                    }\n                    else if (x2 <= x1 && x2 < axisx.min) {\n                        if (x1 < axisx.min)\n                            continue;\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.min;\n                    }\n\n                    // clip with xmax\n                    if (x1 >= x2 && x1 > axisx.max) {\n                        if (x2 > axisx.max)\n                            continue;\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.max;\n                    }\n                    else if (x2 >= x1 && x2 > axisx.max) {\n                        if (x1 > axisx.max)\n                            continue;\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.max;\n                    }\n\n                    if (x1 != prevx || y1 != prevy)\n                        ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);\n\n                    prevx = x2;\n                    prevy = y2;\n                    ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);\n                }\n                ctx.stroke();\n            }\n\n            function plotLineArea(datapoints, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    bottom = Math.min(Math.max(0, axisy.min), axisy.max),\n                    i = 0, top, areaOpen = false,\n                    ypos = 1, segmentStart = 0, segmentEnd = 0;\n\n                // we process each segment in two turns, first forward\n                // direction to sketch out top, then once we hit the\n                // end we go backwards to sketch the bottom\n                while (true) {\n                    if (ps > 0 && i > points.length + ps)\n                        break;\n\n                    i += ps; // ps is negative if going backwards\n\n                    var x1 = points[i - ps],\n                        y1 = points[i - ps + ypos],\n                        x2 = points[i], y2 = points[i + ypos];\n\n                    if (areaOpen) {\n                        if (ps > 0 && x1 != null && x2 == null) {\n                            // at turning point\n                            segmentEnd = i;\n                            ps = -ps;\n                            ypos = 2;\n                            continue;\n                        }\n\n                        if (ps < 0 && i == segmentStart + ps) {\n                            // done with the reverse sweep\n                            ctx.fill();\n                            areaOpen = false;\n                            ps = -ps;\n                            ypos = 1;\n                            i = segmentStart = segmentEnd + ps;\n                            continue;\n                        }\n                    }\n\n                    if (x1 == null || x2 == null)\n                        continue;\n\n                    // clip x values\n\n                    // clip with xmin\n                    if (x1 <= x2 && x1 < axisx.min) {\n                        if (x2 < axisx.min)\n                            continue;\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.min;\n                    }\n                    else if (x2 <= x1 && x2 < axisx.min) {\n                        if (x1 < axisx.min)\n                            continue;\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.min;\n                    }\n\n                    // clip with xmax\n                    if (x1 >= x2 && x1 > axisx.max) {\n                        if (x2 > axisx.max)\n                            continue;\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.max;\n                    }\n                    else if (x2 >= x1 && x2 > axisx.max) {\n                        if (x1 > axisx.max)\n                            continue;\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.max;\n                    }\n\n                    if (!areaOpen) {\n                        // open area\n                        ctx.beginPath();\n                        ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));\n                        areaOpen = true;\n                    }\n\n                    // now first check the case where both is outside\n                    if (y1 >= axisy.max && y2 >= axisy.max) {\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));\n                        continue;\n                    }\n                    else if (y1 <= axisy.min && y2 <= axisy.min) {\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));\n                        continue;\n                    }\n\n                    // else it's a bit more complicated, there might\n                    // be a flat maxed out rectangle first, then a\n                    // triangular cutout or reverse; to find these\n                    // keep track of the current x values\n                    var x1old = x1, x2old = x2;\n\n                    // clip the y values, without shortcutting, we\n                    // go through all cases in turn\n\n                    // clip with ymin\n                    if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.min;\n                    }\n                    else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.min;\n                    }\n\n                    // clip with ymax\n                    if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.max;\n                    }\n                    else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.max;\n                    }\n\n                    // if the x value was changed we got a rectangle\n                    // to fill\n                    if (x1 != x1old) {\n                        ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));\n                        // it goes to (x1, y1), but we fill that below\n                    }\n\n                    // fill triangular section, this sometimes result\n                    // in redundant points if (x1, y1) hasn't changed\n                    // from previous line to, but we just ignore that\n                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));\n                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n\n                    // fill the other rectangle if it's there\n                    if (x2 != x2old) {\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n                        ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));\n                    }\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n            ctx.lineJoin = \"round\";\n\n            var lw = series.lines.lineWidth,\n                sw = series.shadowSize;\n            // FIXME: consider another form of shadow when filling is turned on\n            if (lw > 0 && sw > 0) {\n                // draw shadow as a thick and thin line with transparency\n                ctx.lineWidth = sw;\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n                // position shadow at angle from the mid of line\n                var angle = Math.PI/18;\n                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/2), Math.cos(angle) * (lw/2 + sw/2), series.xaxis, series.yaxis);\n                ctx.lineWidth = sw/2;\n                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/4), Math.cos(angle) * (lw/2 + sw/4), series.xaxis, series.yaxis);\n            }\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);\n            if (fillStyle) {\n                ctx.fillStyle = fillStyle;\n                plotLineArea(series.datapoints, series.xaxis, series.yaxis);\n            }\n\n            if (lw > 0)\n                plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function drawSeriesPoints(series) {\n            function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {\n                var points = datapoints.points, ps = datapoints.pointsize;\n\n                for (var i = 0; i < points.length; i += ps) {\n                    var x = points[i], y = points[i + 1];\n                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\n                        continue;\n\n                    ctx.beginPath();\n                    x = axisx.p2c(x);\n                    y = axisy.p2c(y) + offset;\n                    if (symbol == \"circle\")\n                        ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);\n                    else\n                        symbol(ctx, x, y, radius, shadow);\n                    ctx.closePath();\n\n                    if (fillStyle) {\n                        ctx.fillStyle = fillStyle;\n                        ctx.fill();\n                    }\n                    ctx.stroke();\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            var lw = series.points.lineWidth,\n                sw = series.shadowSize,\n                radius = series.points.radius,\n                symbol = series.points.symbol;\n\n            // If the user sets the line width to 0, we change it to a very\n            // small value. A line width of 0 seems to force the default of 1.\n            // Doing the conditional here allows the shadow setting to still be\n            // optional even with a lineWidth of 0.\n\n            if( lw == 0 )\n                lw = 0.0001;\n\n            if (lw > 0 && sw > 0) {\n                // draw shadow in two steps\n                var w = sw / 2;\n                ctx.lineWidth = w;\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n                plotPoints(series.datapoints, radius, null, w + w/2, true,\n                           series.xaxis, series.yaxis, symbol);\n\n                ctx.strokeStyle = \"rgba(0,0,0,0.2)\";\n                plotPoints(series.datapoints, radius, null, w/2, true,\n                           series.xaxis, series.yaxis, symbol);\n            }\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            plotPoints(series.datapoints, radius,\n                       getFillStyle(series.points, series.color), 0, false,\n                       series.xaxis, series.yaxis, symbol);\n            ctx.restore();\n        }\n\n        function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {\n            var left, right, bottom, top,\n                drawLeft, drawRight, drawTop, drawBottom,\n                tmp;\n\n            // in horizontal mode, we start the bar from the left\n            // instead of from the bottom so it appears to be\n            // horizontal rather than vertical\n            if (horizontal) {\n                drawBottom = drawRight = drawTop = true;\n                drawLeft = false;\n                left = b;\n                right = x;\n                top = y + barLeft;\n                bottom = y + barRight;\n\n                // account for negative bars\n                if (right < left) {\n                    tmp = right;\n                    right = left;\n                    left = tmp;\n                    drawLeft = true;\n                    drawRight = false;\n                }\n            }\n            else {\n                drawLeft = drawRight = drawTop = true;\n                drawBottom = false;\n                left = x + barLeft;\n                right = x + barRight;\n                bottom = b;\n                top = y;\n\n                // account for negative bars\n                if (top < bottom) {\n                    tmp = top;\n                    top = bottom;\n                    bottom = tmp;\n                    drawBottom = true;\n                    drawTop = false;\n                }\n            }\n\n            // clip\n            if (right < axisx.min || left > axisx.max ||\n                top < axisy.min || bottom > axisy.max)\n                return;\n\n            if (left < axisx.min) {\n                left = axisx.min;\n                drawLeft = false;\n            }\n\n            if (right > axisx.max) {\n                right = axisx.max;\n                drawRight = false;\n            }\n\n            if (bottom < axisy.min) {\n                bottom = axisy.min;\n                drawBottom = false;\n            }\n\n            if (top > axisy.max) {\n                top = axisy.max;\n                drawTop = false;\n            }\n\n            left = axisx.p2c(left);\n            bottom = axisy.p2c(bottom);\n            right = axisx.p2c(right);\n            top = axisy.p2c(top);\n\n            // fill the bar\n            if (fillStyleCallback) {\n                c.fillStyle = fillStyleCallback(bottom, top);\n                c.fillRect(left, top, right - left, bottom - top)\n            }\n\n            // draw outline\n            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {\n                c.beginPath();\n\n                // FIXME: inline moveTo is buggy with excanvas\n                c.moveTo(left, bottom);\n                if (drawLeft)\n                    c.lineTo(left, top);\n                else\n                    c.moveTo(left, top);\n                if (drawTop)\n                    c.lineTo(right, top);\n                else\n                    c.moveTo(right, top);\n                if (drawRight)\n                    c.lineTo(right, bottom);\n                else\n                    c.moveTo(right, bottom);\n                if (drawBottom)\n                    c.lineTo(left, bottom);\n                else\n                    c.moveTo(left, bottom);\n                c.stroke();\n            }\n        }\n\n        function drawSeriesBars(series) {\n            function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {\n                var points = datapoints.points, ps = datapoints.pointsize;\n\n                for (var i = 0; i < points.length; i += ps) {\n                    if (points[i] == null)\n                        continue;\n                    drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            // FIXME: figure out a way to add shadows (for instance along the right edge)\n            ctx.lineWidth = series.bars.lineWidth;\n            ctx.strokeStyle = series.color;\n\n            var barLeft;\n\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -series.bars.barWidth;\n                    break;\n                default:\n                    barLeft = -series.bars.barWidth / 2;\n            }\n\n            var fillStyleCallback = series.bars.fill ? function (bottom, top) { return getFillStyle(series.bars, series.color, bottom, top); } : null;\n            plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function getFillStyle(filloptions, seriesColor, bottom, top) {\n            var fill = filloptions.fill;\n            if (!fill)\n                return null;\n\n            if (filloptions.fillColor)\n                return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);\n\n            var c = $.color.parse(seriesColor);\n            c.a = typeof fill == \"number\" ? fill : 0.4;\n            c.normalize();\n            return c.toString();\n        }\n\n        function insertLegend() {\n\n            if (options.legend.container != null) {\n                $(options.legend.container).html(\"\");\n            } else {\n                placeholder.find(\".legend\").remove();\n            }\n\n            if (!options.legend.show) {\n                return;\n            }\n\n            var fragments = [], entries = [], rowStarted = false,\n                lf = options.legend.labelFormatter, s, label;\n\n            // Build a list of legend entries, with each having a label and a color\n\n            for (var i = 0; i < series.length; ++i) {\n                s = series[i];\n                if (s.label) {\n                    label = lf ? lf(s.label, s) : s.label;\n                    if (label) {\n                        entries.push({\n                            label: label,\n                            color: s.color\n                        });\n                    }\n                }\n            }\n\n            // Sort the legend using either the default or a custom comparator\n\n            if (options.legend.sorted) {\n                if ($.isFunction(options.legend.sorted)) {\n                    entries.sort(options.legend.sorted);\n                } else if (options.legend.sorted == \"reverse\") {\n                \tentries.reverse();\n                } else {\n                    var ascending = options.legend.sorted != \"descending\";\n                    entries.sort(function(a, b) {\n                        return a.label == b.label ? 0 : (\n                            (a.label < b.label) != ascending ? 1 : -1   // Logical XOR\n                        );\n                    });\n                }\n            }\n\n            // Generate markup for the list of entries, in their final order\n\n            for (var i = 0; i < entries.length; ++i) {\n\n                var entry = entries[i];\n\n                if (i % options.legend.noColumns == 0) {\n                    if (rowStarted)\n                        fragments.push('</tr>');\n                    fragments.push('<tr>');\n                    rowStarted = true;\n                }\n\n                fragments.push(\n                    '<td class=\"legendColorBox\"><div style=\"border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px\"><div style=\"width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden\"></div></div></td>' +\n                    '<td class=\"legendLabel\">' + entry.label + '</td>'\n                );\n            }\n\n            if (rowStarted)\n                fragments.push('</tr>');\n\n            if (fragments.length == 0)\n                return;\n\n            var table = '<table style=\"font-size:smaller;color:' + options.grid.color + '\">' + fragments.join(\"\") + '</table>';\n            if (options.legend.container != null)\n                $(options.legend.container).html(table);\n            else {\n                var pos = \"\",\n                    p = options.legend.position,\n                    m = options.legend.margin;\n                if (m[0] == null)\n                    m = [m, m];\n                if (p.charAt(0) == \"n\")\n                    pos += 'top:' + (m[1] + plotOffset.top) + 'px;';\n                else if (p.charAt(0) == \"s\")\n                    pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';\n                if (p.charAt(1) == \"e\")\n                    pos += 'right:' + (m[0] + plotOffset.right) + 'px;';\n                else if (p.charAt(1) == \"w\")\n                    pos += 'left:' + (m[0] + plotOffset.left) + 'px;';\n                var legend = $('<div class=\"legend\">' + table.replace('style=\"', 'style=\"position:absolute;' + pos +';') + '</div>').appendTo(placeholder);\n                if (options.legend.backgroundOpacity != 0.0) {\n                    // put in the transparent background\n                    // separately to avoid blended labels and\n                    // label boxes\n                    var c = options.legend.backgroundColor;\n                    if (c == null) {\n                        c = options.grid.backgroundColor;\n                        if (c && typeof c == \"string\")\n                            c = $.color.parse(c);\n                        else\n                            c = $.color.extract(legend, 'background-color');\n                        c.a = 1;\n                        c = c.toString();\n                    }\n                    var div = legend.children();\n                    $('<div style=\"position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos +'background-color:' + c + ';\"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);\n                }\n            }\n        }\n\n\n        // interactive features\n\n        var highlights = [],\n            redrawTimeout = null;\n\n        // returns the data item the mouse is over, or null if none is found\n        function findNearbyItem(mouseX, mouseY, seriesFilter) {\n            var maxDistance = options.grid.mouseActiveRadius,\n                smallestDistance = maxDistance * maxDistance + 1,\n                item = null, foundPoint = false, i, j, ps;\n\n            for (i = series.length - 1; i >= 0; --i) {\n                if (!seriesFilter(series[i]))\n                    continue;\n\n                var s = series[i],\n                    axisx = s.xaxis,\n                    axisy = s.yaxis,\n                    points = s.datapoints.points,\n                    mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster\n                    my = axisy.c2p(mouseY),\n                    maxx = maxDistance / axisx.scale,\n                    maxy = maxDistance / axisy.scale;\n\n                ps = s.datapoints.pointsize;\n                // with inverse transforms, we can't use the maxx/maxy\n                // optimization, sadly\n                if (axisx.options.inverseTransform)\n                    maxx = Number.MAX_VALUE;\n                if (axisy.options.inverseTransform)\n                    maxy = Number.MAX_VALUE;\n\n                if (s.lines.show || s.points.show) {\n                    for (j = 0; j < points.length; j += ps) {\n                        var x = points[j], y = points[j + 1];\n                        if (x == null)\n                            continue;\n\n                        // For points and lines, the cursor must be within a\n                        // certain distance to the data point\n                        if (x - mx > maxx || x - mx < -maxx ||\n                            y - my > maxy || y - my < -maxy)\n                            continue;\n\n                        // We have to calculate distances in pixels, not in\n                        // data units, because the scales of the axes may be different\n                        var dx = Math.abs(axisx.p2c(x) - mouseX),\n                            dy = Math.abs(axisy.p2c(y) - mouseY),\n                            dist = dx * dx + dy * dy; // we save the sqrt\n\n                        // use <= to ensure last point takes precedence\n                        // (last generally means on top of)\n                        if (dist < smallestDistance) {\n                            smallestDistance = dist;\n                            item = [i, j / ps];\n                        }\n                    }\n                }\n\n                if (s.bars.show && !item) { // no other point can be nearby\n\n                    var barLeft, barRight;\n\n                    switch (s.bars.align) {\n                        case \"left\":\n                            barLeft = 0;\n                            break;\n                        case \"right\":\n                            barLeft = -s.bars.barWidth;\n                            break;\n                        default:\n                            barLeft = -s.bars.barWidth / 2;\n                    }\n\n                    barRight = barLeft + s.bars.barWidth;\n\n                    for (j = 0; j < points.length; j += ps) {\n                        var x = points[j], y = points[j + 1], b = points[j + 2];\n                        if (x == null)\n                            continue;\n\n                        // for a bar graph, the cursor must be inside the bar\n                        if (series[i].bars.horizontal ?\n                            (mx <= Math.max(b, x) && mx >= Math.min(b, x) &&\n                             my >= y + barLeft && my <= y + barRight) :\n                            (mx >= x + barLeft && mx <= x + barRight &&\n                             my >= Math.min(b, y) && my <= Math.max(b, y)))\n                                item = [i, j / ps];\n                    }\n                }\n            }\n\n            if (item) {\n                i = item[0];\n                j = item[1];\n                ps = series[i].datapoints.pointsize;\n\n                return { datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),\n                         dataIndex: j,\n                         series: series[i],\n                         seriesIndex: i };\n            }\n\n            return null;\n        }\n\n        function onMouseMove(e) {\n            if (options.grid.hoverable)\n                triggerClickHoverEvent(\"plothover\", e,\n                                       function (s) { return s[\"hoverable\"] != false; });\n        }\n\n        function onMouseLeave(e) {\n            if (options.grid.hoverable)\n                triggerClickHoverEvent(\"plothover\", e,\n                                       function (s) { return false; });\n        }\n\n        function onClick(e) {\n            triggerClickHoverEvent(\"plotclick\", e,\n                                   function (s) { return s[\"clickable\"] != false; });\n        }\n\n        // trigger click or hover event (they send the same parameters\n        // so we share their code)\n        function triggerClickHoverEvent(eventname, event, seriesFilter) {\n            var offset = eventHolder.offset(),\n                canvasX = event.pageX - offset.left - plotOffset.left,\n                canvasY = event.pageY - offset.top - plotOffset.top,\n            pos = canvasToAxisCoords({ left: canvasX, top: canvasY });\n\n            pos.pageX = event.pageX;\n            pos.pageY = event.pageY;\n\n            var item = findNearbyItem(canvasX, canvasY, seriesFilter);\n\n            if (item) {\n                // fill in mouse pos for any listeners out there\n                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);\n                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);\n            }\n\n            if (options.grid.autoHighlight) {\n                // clear auto-highlights\n                for (var i = 0; i < highlights.length; ++i) {\n                    var h = highlights[i];\n                    if (h.auto == eventname &&\n                        !(item && h.series == item.series &&\n                          h.point[0] == item.datapoint[0] &&\n                          h.point[1] == item.datapoint[1]))\n                        unhighlight(h.series, h.point);\n                }\n\n                if (item)\n                    highlight(item.series, item.datapoint, eventname);\n            }\n\n            placeholder.trigger(eventname, [ pos, item ]);\n        }\n\n        function triggerRedrawOverlay() {\n            var t = options.interaction.redrawOverlayInterval;\n            if (t == -1) {      // skip event queue\n                drawOverlay();\n                return;\n            }\n\n            if (!redrawTimeout)\n                redrawTimeout = setTimeout(drawOverlay, t);\n        }\n\n        function drawOverlay() {\n            redrawTimeout = null;\n\n            // draw highlights\n            octx.save();\n            overlay.clear();\n            octx.translate(plotOffset.left, plotOffset.top);\n\n            var i, hi;\n            for (i = 0; i < highlights.length; ++i) {\n                hi = highlights[i];\n\n                if (hi.series.bars.show)\n                    drawBarHighlight(hi.series, hi.point);\n                else\n                    drawPointHighlight(hi.series, hi.point);\n            }\n            octx.restore();\n\n            executeHooks(hooks.drawOverlay, [octx]);\n        }\n\n        function highlight(s, point, auto) {\n            if (typeof s == \"number\")\n                s = series[s];\n\n            if (typeof point == \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i == -1) {\n                highlights.push({ series: s, point: point, auto: auto });\n\n                triggerRedrawOverlay();\n            }\n            else if (!auto)\n                highlights[i].auto = false;\n        }\n\n        function unhighlight(s, point) {\n            if (s == null && point == null) {\n                highlights = [];\n                triggerRedrawOverlay();\n                return;\n            }\n\n            if (typeof s == \"number\")\n                s = series[s];\n\n            if (typeof point == \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i != -1) {\n                highlights.splice(i, 1);\n\n                triggerRedrawOverlay();\n            }\n        }\n\n        function indexOfHighlight(s, p) {\n            for (var i = 0; i < highlights.length; ++i) {\n                var h = highlights[i];\n                if (h.series == s && h.point[0] == p[0]\n                    && h.point[1] == p[1])\n                    return i;\n            }\n            return -1;\n        }\n\n        function drawPointHighlight(series, point) {\n            var x = point[0], y = point[1],\n                axisx = series.xaxis, axisy = series.yaxis,\n                highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();\n\n            if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\n                return;\n\n            var pointRadius = series.points.radius + series.points.lineWidth / 2;\n            octx.lineWidth = pointRadius;\n            octx.strokeStyle = highlightColor;\n            var radius = 1.5 * pointRadius;\n            x = axisx.p2c(x);\n            y = axisy.p2c(y);\n\n            octx.beginPath();\n            if (series.points.symbol == \"circle\")\n                octx.arc(x, y, radius, 0, 2 * Math.PI, false);\n            else\n                series.points.symbol(octx, x, y, radius, false);\n            octx.closePath();\n            octx.stroke();\n        }\n\n        function drawBarHighlight(series, point) {\n            var highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),\n                fillStyle = highlightColor,\n                barLeft;\n\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -series.bars.barWidth;\n                    break;\n                default:\n                    barLeft = -series.bars.barWidth / 2;\n            }\n\n            octx.lineWidth = series.bars.lineWidth;\n            octx.strokeStyle = highlightColor;\n\n            drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth,\n                    function () { return fillStyle; }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);\n        }\n\n        function getColorOrGradient(spec, bottom, top, defaultColor) {\n            if (typeof spec == \"string\")\n                return spec;\n            else {\n                // assume this is a gradient spec; IE currently only\n                // supports a simple vertical gradient properly, so that's\n                // what we support too\n                var gradient = ctx.createLinearGradient(0, top, 0, bottom);\n\n                for (var i = 0, l = spec.colors.length; i < l; ++i) {\n                    var c = spec.colors[i];\n                    if (typeof c != \"string\") {\n                        var co = $.color.parse(defaultColor);\n                        if (c.brightness != null)\n                            co = co.scale('rgb', c.brightness);\n                        if (c.opacity != null)\n                            co.a *= c.opacity;\n                        c = co.toString();\n                    }\n                    gradient.addColorStop(i / (l - 1), c);\n                }\n\n                return gradient;\n            }\n        }\n    }\n\n    // Add the plot function to the top level of the jQuery object\n\n    $.plot = function(placeholder, data, options) {\n        //var t0 = new Date();\n        var plot = new Plot($(placeholder), data, options, $.plot.plugins);\n        //(window.console ? console.log : alert)(\"time used (msecs): \" + ((new Date()).getTime() - t0.getTime()));\n        return plot;\n    };\n\n    $.plot.version = \"0.8.3\";\n\n    $.plot.plugins = [];\n\n    // Also add the plot function as a chainable property\n\n    $.fn.plot = function(data, options) {\n        return this.each(function() {\n            $.plot(this, data, options);\n        });\n    };\n\n    // round to nearby lower multiple of base\n    function floorInBase(n, base) {\n        return base * Math.floor(n / base);\n    }\n\n})(jQuery);\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}